<?php
/**
 * Matomo - free/libre analytics platform
 *
 * @link https://matomo.org
 * @license http://www.gnu.org/licenses/gpl-3.0.html GPL v3 or later
 *
 */

namespace Piwik\Plugins\CoreConsole\Commands;

use Piwik\Container\StaticContainer;
use Piwik\Dependency\Prefixer;
use Piwik\Filesystem;
use Piwik\Http;
use Piwik\Plugin\ConsoleCommand;
use Piwik\Plugin\Manager;
use Matomo\Dependencies\Psr\Log\LoggerInterface;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Output\OutputInterface;

/**
 */
class PrefixDependency extends ConsoleCommand
{
    const PHP_SCOPER_VERSION = '0.17.5';
    // const PHP_SCOPER_URL = 'https://github.com/humbug/php-scoper/releases/download/' . self::PHP_SCOPER_VERSION . '/php-scoper.phar';
    // using forked version for now
    const PHP_SCOPER_URL = 'https://github.com/diosmosis/php-scoper/releases/download/included-ns3/php-scoper.phar';

    const SUPPORTED_CORE_DEPENDENCIES = [
        'twig/twig',
        'monolog/monolog',
        'symfony/monolog-bridge',
    ];
    const PROXY_FILE_MARKER = '/* this file was generated by the development:prefix-dependency Matomo command */';
    const NAME = 'composer:prefix-dependency';

    protected function configure()
    {
        $this->setName(self::NAME);
        $this->setDescription('Prefix the namespace of every file in certain composer dependencies using php-scoper. Used to'
            . ' avoid collisions in environments where other third party software might use the same dependencies,'
            . ' like Matomo for Wordpress.');
        $this->addOption('php-scoper-path', null, InputOption::VALUE_REQUIRED,
            'Specify a custom path to php-scoper. If not supplied, the PHAR will be downloaded from github.');
        $this->addOption('composer-path', null, InputOption::VALUE_REQUIRED,
            'Path to composer. Required to generate a new autoloader.', getenv('COMPOSER_BINARY'));
        $this->addOption('keep-originals', null, InputOption::VALUE_NONE,
            'If supplied, keeps the original composer dependency files after prefixing (this may break autoloading).');
        $this->addOption('plugin', null, InputOption::VALUE_REQUIRED, 'Prefix dependencies for a specific plugin.');
    }

    protected function execute(InputInterface $input, OutputInterface $output)
    {
        if ($this->isBeingInstalledAsComposerDependency()) {
            $output->writeln('Detected Matomo being installed as composer dependency, skipping prefixing.');
            $this->setUpPrefixRemovingAutoloader();
            return;
        }

        $this->removePrefixRemovingAutoloader(); // can remain during development

        $composerPath = $this->getComposerPath($input);
        $phpScoperBinary = $this->downloadPhpScoperIfNeeded($input, $output);

        $prefixer = new Prefixer(StaticContainer::get(LoggerInterface::class));
        $prefixer->setPathToPhpScoper($phpScoperBinary);

        $plugin = $this->getPlugin($input);
        if ($plugin) {
            $output->writeln("Will process dependencies of plugin $plugin.");
            $prefixer->setComponentToPrefix($plugin);
            $prefixer->generatePhpScoperFileIfNotExists();
        } else {
            $prefixer->setComponentToPrefix('core');
        }

        $output->writeln("Will run php-scoper on the following dependencies: ["
            . implode(', ', $prefixer->getDependenciesToPrefix()) . ']');

        $output->writeln("<info>Prefixing dependencies...</info>");
        $prefixer->run();

        $output->writeln("");
        $output->writeln("<info>Regenerating autoloader...</info>");
        $this->generatePrefixedAutoloader($plugin, $prefixer->getDependenciesToPrefix(), $composerPath, $input, $output);
        $this->proxyOriginalComposerAutoloader($plugin, $output);

        $output->writeln("<info>Done.</info>");
    }

    private function downloadPhpScoperIfNeeded(InputInterface $input, OutputInterface $output)
    {
        $customPhpScoperPath = $input->getOption('php-scoper-path');
        if ($customPhpScoperPath) {
            return $customPhpScoperPath;
        }

        $outputPath = PIWIK_INCLUDE_PATH . '/php-scoper.phar';
        if (is_file($outputPath)) {
            $output->writeln("Found existing phar.");
            return $outputPath;
        }

        $output->writeln("Downloading php-scoper from github...");
        Http::fetchRemoteFile(self::PHP_SCOPER_URL, $outputPath);
        $output->writeln("...Finished.");

        return $outputPath;
    }

    private function getComposerPath(InputInterface $input)
    {
        $composerPath = $input->getOption('composer-path');
        if (empty($composerPath)) {
            throw new \InvalidArgumentException('The --composer-path option is required.');
        }

        if (!is_file($composerPath)) {
            throw new \InvalidArgumentException('--composer-path value "' . $composerPath . '" is not a file.');
        }

        return $composerPath;
    }

    private function generatePrefixedAutoloader($plugin, $dependenciesToPrefix, $composerPath, InputInterface $input, OutputInterface $output)
    {
        $basePath = $plugin ? PIWIK_INCLUDE_PATH . '/plugins/' . $plugin : PIWIK_INCLUDE_PATH;
        $prefixed = "$basePath/vendor/prefixed";

        if (!empty($dependenciesToPrefix)) {
            file_put_contents("$prefixed/composer.json", '{ "autoload": { "classmap": [""] } }');

            $output->writeln("Generating prefixed autoloader...");

            $composerCommand = escapeshellarg($composerPath) . " --working-dir=" . escapeshellarg($prefixed)
                . " dump-autoload --classmap-authoritative --no-interaction";
            passthru($composerCommand, $returnCode);
            if ($returnCode) {
                throw new \Exception("Failed to invoke composer! Command was: $composerCommand");
            }

            Filesystem::remove("$prefixed/autoload.php");
            Filesystem::unlinkRecursive("$prefixed/composer", true);

            Filesystem::remove("$prefixed/composer.json");

            $removeOriginal = !$input->getOption('keep-originals');
            if ($removeOriginal) {
                foreach ($dependenciesToPrefix as $dependency) {
                    $vendorPath = "$basePath/vendor/$dependency";
                    Filesystem::unlinkRecursive($vendorPath, true);
                }
            }
        }

        $output->writeln("Regenerating unprefixed autoloader...");

        // composer does not recognize recursive symbolic links
        foreach (scandir(PIWIK_INCLUDE_PATH . '/tests/PHPUnit/proxy') as $item) {
            if ($item === '.' || $item === '..') {
                continue;
            }

            $path = PIWIK_INCLUDE_PATH . '/tests/PHPUnit/proxy/' . $item;
            if (is_link($path)) {
                unlink($path);
            }
        }

        $composerCommand = escapeshellarg($composerPath) . ' --working-dir=' . escapeshellarg($basePath)
            . " dump-autoload --classmap-authoritative --no-interaction -q";
        passthru($composerCommand, $returnCode);
        if ($returnCode) {
            throw new \Exception("Failed to invoke composer! Command was: $composerCommand");
        }
    }

    private function proxyOriginalComposerAutoloader($plugin, OutputInterface $output)
    {
        $vendorPath = $plugin ? PIWIK_INCLUDE_PATH . '/plugins/' . $plugin . '/vendor' : PIWIK_VENDOR_PATH;

        $autoloadPath = $vendorPath . '/autoload.php';
        $originalAutoloadPath = $vendorPath . '/autoload_original.php';
        $proxyFileMarker = self::PROXY_FILE_MARKER;

        $proxyAutoloadContent = <<<EOF
<?php
$proxyFileMarker

\$originalLoader = require_once __DIR__ . DIRECTORY_SEPARATOR . 'autoload_original.php';

if (is_file(__DIR__ . '/prefixed/vendor/autoload.php')) {
    require_once __DIR__ . '/prefixed/vendor/autoload.php';
}

return \$originalLoader;
EOF;

        if ($this->isFileAutoloadProxy($autoloadPath)) {
            $output->writeln("<comment>Proxy autoload.php already exists, skipping generation.</comment>");
            return;
        }

        if (!is_file($autoloadPath)) {
            $output->writeln("<error>Cannot find original composer autoloader!</error>");
            return;
        }

        copy($autoloadPath, $originalAutoloadPath);
        file_put_contents($autoloadPath, $proxyAutoloadContent);
        $output->writeln("Generated proxy autoload.php.");
    }

    private function isFileAutoloadProxy($autoloadPath)
    {
        if (!is_file($autoloadPath)) {
            return false;
        }

        $contents = file_get_contents($autoloadPath);
        return strpos($contents, self::PROXY_FILE_MARKER) !== false;
    }

    private function getPlugin(InputInterface $input)
    {
        $plugin = $input->getOption('plugin');
        if (!$plugin) {
            return null;
        }

        if (!Manager::getInstance()->isPluginInFilesystem($plugin)) {
            throw new \InvalidArgumentException("Plugin $plugin does not exist!");
        }

        return $plugin;
    }

    private function isBeingInstalledAsComposerDependency()
    {
        $matomoVendorPath = PIWIK_INCLUDE_PATH . '/vendor';
        return !is_dir($matomoVendorPath);
    }

    private function setUpPrefixRemovingAutoloader()
    {
        $prefixAutoloadPath = PIWIK_INCLUDE_PATH . '/prefixAutoload.php';

        $content = '<?php return new \Piwik\Dependency\PrefixRemovingAutoloader();';
        file_put_contents($prefixAutoloadPath, $content);
    }

    private function removePrefixRemovingAutoloader()
    {
        $prefixAutoloadPath = PIWIK_INCLUDE_PATH . '/prefixAutoload.php';
        if (is_file($prefixAutoloadPath)) {
            unlink($prefixAutoloadPath);
        }
    }
}
