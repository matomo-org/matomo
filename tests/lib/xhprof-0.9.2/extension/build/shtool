#!/bin/sh
##
##  GNU shtool -- The GNU Portable Shell Tool
##  Copyright (c) 1994-2008 Ralf S. Engelschall <rse@engelschall.com>
##
##  See http://www.gnu.org/software/shtool/ for more information.
##  See ftp://ftp.gnu.org/gnu/shtool/ for latest version.
##
##  Version:  2.0.8 (18-Jul-2008)
##  Contents: all available modules
##

##
##  This program is free software; you can redistribute it and/or modify
##  it under the terms of the GNU General Public License as published by
##  the Free Software Foundation; either version 2 of the License, or
##  (at your option) any later version.
##
##  This program is distributed in the hope that it will be useful,
##  but WITHOUT ANY WARRANTY; without even the implied warranty of
##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
##  General Public License for more details.
##
##  You should have received a copy of the GNU General Public License
##  along with this program; if not, write to the Free Software
##  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
##  USA, or contact Ralf S. Engelschall <rse@engelschall.com>.
##
##  NOTICE: Given that you include this file verbatim into your own
##  source tree, you are justified in saying that it remains separate
##  from your package, and that this way you are simply just using GNU
##  shtool. So, in this situation, there is no requirement that your
##  package itself is licensed under the GNU General Public License in
##  order to take advantage of GNU shtool.
##

##
##  Usage: shtool [<options>] [<cmd-name> [<cmd-options>] [<cmd-args>]]
##
##  Available commands:
##    echo       Print string with optional construct expansion
##    mdate      Pretty-print modification time of a file or dir
##    table      Pretty-print a field-separated list as a table
##    prop       Display progress with a running propeller
##    move       Move files with simultaneous substitution
##    install    Install a program, script or datafile
##    mkdir      Make one or more directories
##    mkln       Make link with calculation of relative paths
##    mkshadow   Make a shadow tree through symbolic links
##    fixperm    Fix file permissions inside a source tree
##    rotate     Logfile rotation
##    tarball    Roll distribution tarballs
##    subst      Apply sed(1) substitution operations
##    platform   Platform Identification Utility
##    arx        Extended archive command
##    slo        Separate linker options by library class
##    scpp       Sharing C Pre-Processor
##    version    Maintain a version information file
##    path       Deal with program paths
##

#   maximum Bourne-Shell compatibility
if [ ".$ZSH_VERSION" != . ] && (emulate sh) >/dev/null 2>&1; then
    #   reconfigure zsh(1)
    emulate sh
    NULLCMD=:
    alias -g '${1+"$@"}'='"$@"'
elif [ ".$BASH_VERSION" != . ] && (set -o posix) >/dev/null 2>&1; then
    #   reconfigure bash(1)
    set -o posix
fi

#   maximum independence of NLS nuisances
for var in \
    LANG LANGUAGE LC_ADDRESS LC_ALL LC_COLLATE LC_CTYPE LC_IDENTIFICATION \
    LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER \
    LC_TELEPHONE LC_TIME
do
    if (set +x; test -z "`(eval $var=C; export $var) 2>&1`"); then
        eval $var=C; export $var
    else
        unset $var
    fi
done

#   initial command line handling
if [ $# -eq 0 ]; then
    echo "$0:Error: invalid command line" 1>&2
    echo "$0:Hint:  run \`$0 -h' for usage" 1>&2
    exit 1
fi
if [ ".$1" = ".-h" ] || [ ".$1" = ".--help" ]; then
    echo "This is GNU shtool, version 2.0.8 (18-Jul-2008)"
    echo 'Copyright (c) 1994-2008 Ralf S. Engelschall <rse@engelschall.com>'
    echo 'Report bugs to <bug-shtool@gnu.org>'
    echo ''
    echo 'Usage: shtool [<options>] [<cmd-name> [<cmd-options>] [<cmd-args>]]'
    echo ''
    echo 'Available global <options>:'
    echo '  -v, --version   display shtool version information'
    echo '  -h, --help      display shtool usage help page (this one)'
    echo '  -d, --debug     display shell trace information'
    echo '  -r, --recreate  recreate this shtool script via shtoolize'
    echo ''
    echo 'Available <cmd-name> [<cmd-options>] [<cmd-args>]:'
    echo '  echo     [-n|--newline] [-e|--expand] [<string> ...]'
    echo '  mdate    [-n|--newline] [-z|--zero] [-s|--shorten] [-d|--digits]'
    echo '           [-f|--field-sep <str>] [-o|--order <spec>] <path>'
    echo '  table    [-F|--field-sep <sep>] [-w|--width <width>] [-c|--columns'
    echo '           <cols>] [-s|--strip <strip>] <str><sep><str>...'
    echo '  prop     [-p|--prefix <str>]'
    echo '  move     [-v|--verbose] [-t|--trace] [-e|--expand] [-p|--preserve]'
    echo '           <src-file> <dst-file>'
    echo '  install  [-v|--verbose] [-t|--trace] [-d|--mkdir] [-c|--copy]'
    echo '           [-C|--compare-copy] [-s|--strip] [-m|--mode <mode>]'
    echo '           [-o|--owner <owner>] [-g|--group <group>] [-e|--exec'
    echo '           <sed-cmd>] <file> [<file> ...] <path>'
    echo '  mkdir    [-t|--trace] [-f|--force] [-p|--parents] [-m|--mode'
    echo '           <mode>] [-o|--owner <owner>] [-g|--group <group>] <dir>'
    echo '           [<dir> ...]'
    echo '  mkln     [-t|--trace] [-f|--force] [-s|--symbolic] <src-path>'
    echo '           [<src-path> ...] <dst-path>'
    echo '  mkshadow [-v|--verbose] [-t|--trace] [-a|--all] <src-dir> <dst-dir>'
    echo '  fixperm  [-v|--verbose] [-t|--trace] <path> [<path> ...]'
    echo '  rotate   [-v|--verbose] [-t|--trace] [-f|--force] [-n|--num-files'
    echo '           <count>] [-s|--size <size>] [-c|--copy] [-r|--remove]'
    echo '           [-a|--archive-dir <dir>] [-z|--compress [<tool>:]<level>]'
    echo '           [-b|--background] [-d|--delay] [-p|--pad <len>] [-m|--mode'
    echo '           <mode>] [-o|--owner <owner>] [-g|--group <group>] [-M|--migrate'
    echo '           <cmd>] [-P|--prolog <cmd>] [-E|--epilog <cmd>] <file> [...]'
    echo '  tarball  [-t|--trace] [-v|--verbose] [-o|--output <tarball>]'
    echo '           [-c|--compress <prog>] [-d|--directory <dir>] [-u|--user'
    echo '           <user>] [-g|--group <group>] [-e|--exclude <pattern>]'
    echo '           <path> [<path> ...]'
    echo '  subst    [-v|--verbose] [-t|--trace] [-n|--nop] [-w|--warning]'
    echo '           [-q|--quiet] [-s|--stealth] [-i|--interactive] [-b|--backup'
    echo '           <ext>] [-e|--exec <cmd>] [-f|--file <cmd-file>] [<file>]'
    echo '           [...]'
    echo '  platform [-F|--format <format>] [-S|--sep <string>] [-C|--conc'
    echo '           <string>] [-L|--lower] [-U|--upper] [-v|--verbose]'
    echo '           [-c|--concise] [-n|--no-newline] [-t|--type <type>]'
    echo '           [-V|--version] [-h|--help]'
    echo '  arx      [-t|--trace] [-C|--command <cmd>] <op> <archive> [<file>'
    echo '           ...]'
    echo '  slo      [-p|--prefix <str>] -- -L<dir> -l<lib> [-L<dir> -l<lib>'
    echo '           ...]'
    echo '  scpp     [-v|--verbose] [-p|--preserve] [-f|--filter <filter>]'
    echo '           [-o|--output <ofile>] [-t|--template <tfile>] [-M|--mark'
    echo '           <mark>] [-D|--define <dname>] [-C|--class <cname>]'
    echo '           <file> [<file> ...]'
    echo '  version  [-l|--language <lang>] [-n|--name <name>] [-p|--prefix'
    echo '           <prefix>] [-s|--set <version>] [-e|--edit] [-i|--increase'
    echo '           <knob>] [-d|--display <type>] <file>'
    echo '  path     [-s|--suppress] [-r|--reverse] [-d|--dirname] [-b|--basename]'
    echo '           [-m|--magic] [-p|--path <path>] <str> [<str> ...]'
    echo ''
    exit 0
fi
if [ ".$1" = ".-v" ] || [ ".$1" = ".--version" ]; then
    echo "GNU shtool 2.0.8 (18-Jul-2008)"
    exit 0
fi
if [ ".$1" = ".-r" ] || [ ".$1" = ".--recreate" ]; then
    shtoolize -oshtool all
    exit 0
fi
if [ ".$1" = ".-d" ] || [ ".$1" = ".--debug" ]; then
    shift
    set -x
fi
name=`echo "$0" | sed -e 's;.*/\([^/]*\)$;\1;' -e 's;-sh$;;' -e 's;\.sh$;;'`
case "$name" in
    echo|mdate|table|prop|move|install|mkdir|mkln|mkshadow|fixperm|rotate|tarball|subst|platform|arx|slo|scpp|version|path )
        #   implicit tool command selection
        tool="$name"
        ;;
    * )
        #   explicit tool command selection
        tool="$1"
        shift
        ;;
esac
arg_spec=""
opt_spec=""
gen_tmpfile=no

##
##  DISPATCH INTO SCRIPT PROLOG
##

case $tool in
    echo )
        str_tool="echo"
        str_usage="[-n|--newline] [-e|--expand] [<string> ...]"
        arg_spec="0+"
        opt_spec="n.e."
        opt_alias="n:newline,e:expand"
        opt_n=no
        opt_e=no
        ;;
    mdate )
        str_tool="mdate"
        str_usage="[-n|--newline] [-z|--zero] [-s|--shorten] [-d|--digits] [-f|--field-sep <str>] [-o|--order <spec>] <path>"
        arg_spec="1="
        opt_spec="n.z.s.d.f:o:"
        opt_alias="n:newline,z:zero,s:shorten,d:digits,f:field-sep,o:order"
        opt_n=no
        opt_z=no
        opt_s=no
        opt_d=no
        opt_f=" "
        opt_o="dmy"
        ;;
    table )
        str_tool="table"
        str_usage="[-F|--field-sep <sep>] [-w|--width <width>] [-c|--columns <cols>] [-s|--strip <strip>] <str><sep><str>..."
        arg_spec="1+"
        opt_spec="F:w:c:s:"
        opt_alias="F:field-sep,w:width,c:columns,s:strip"
        opt_F=":"
        opt_w=15
        opt_c=3
        opt_s=79
        ;;
    prop )
        str_tool="prop"
        str_usage="[-p|--prefix <str>]"
        arg_spec="0="
        opt_spec="p:"
        opt_alias="p:prefix"
        opt_p=""
        ;;
    move )
        str_tool="move"
        str_usage="[-v|--verbose] [-t|--trace] [-e|--expand] [-p|--preserve] <src-file> <dst-file>"
        arg_spec="2="
        opt_spec="v.t.e.p."
        opt_alias="v:verbose,t:trace,e:expand,p:preserve"
        opt_v=no
        opt_t=no
        opt_e=no
        opt_p=no
        ;;
    install )
        str_tool="install"
        str_usage="[-v|--verbose] [-t|--trace] [-d|--mkdir] [-c|--copy] [-C|--compare-copy] [-s|--strip] [-m|--mode <mode>] [-o|--owner <owner>] [-g|--group <group>] [-e|--exec <sed-cmd>] <file> [<file> ...] <path>"
        arg_spec="1+"
        opt_spec="v.t.d.c.C.s.m:o:g:e+"
        opt_alias="v:verbose,t:trace,d:mkdir,c:copy,C:compare-copy,s:strip,m:mode,o:owner,g:group,e:exec"
        opt_v=no
        opt_t=no
        opt_d=no
        opt_c=no
        opt_C=no
        opt_s=no
        opt_m="0755"
        opt_o=""
        opt_g=""
        opt_e=""
        ;;
    mkdir )
        str_tool="mkdir"
        str_usage="[-t|--trace] [-f|--force] [-p|--parents] [-m|--mode <mode>] [-o|--owner <owner>] [-g|--group <group>] <dir> [<dir> ...]"
        arg_spec="1+"
        opt_spec="t.f.p.m:o:g:"
        opt_alias="t:trace,f:force,p:parents,m:mode,o:owner,g:group"
        opt_t=no
        opt_f=no
        opt_p=no
        opt_m=""
        opt_o=""
        opt_g=""
        ;;
    mkln )
        str_tool="mkln"
        str_usage="[-t|--trace] [-f|--force] [-s|--symbolic] <src-path> [<src-path> ...] <dst-path>"
        arg_spec="2+"
        opt_spec="t.f.s."
        opt_alias="t:trace,f:force,s:symbolic"
        opt_t=no
        opt_f=no
        opt_s=no
        ;;
    mkshadow )
        str_tool="mkshadow"
        str_usage="[-v|--verbose] [-t|--trace] [-a|--all] <src-dir> <dst-dir>"
        arg_spec="2="
        opt_spec="v.t.a."
        opt_alias="v:verbose,t:trace,a:all"
        opt_v=no
        opt_t=no
        opt_a=no
        ;;
    fixperm )
        str_tool="fixperm"
        str_usage="[-v|--verbose] [-t|--trace] <path> [<path> ...]"
        arg_spec="1+"
        opt_spec="v.t."
        opt_alias="v:verbose,t:trace"
        opt_v=no
        opt_t=no
        ;;
    rotate )
        str_tool="rotate"
        str_usage="[-v|--verbose] [-t|--trace] [-f|--force] [-n|--num-files <count>] [-s|--size <size>] [-c|--copy] [-r|--remove] [-a|--archive-dir <dir>] [-z|--compress [<tool>:]<level>] [-b|--background] [-d|--delay] [-p|--pad <len>] [-m|--mode <mode>] [-o|--owner <owner>] [-g|--group <group>] [-M|--migrate <cmd>] [-P|--prolog <cmd>] [-E|--epilog <cmd>] <file> [...]"
        arg_spec="1+"
        opt_spec="v.t.f.n:s:c.r.a:z:b.d.p:o:g:m:M:P:E:"
        opt_alias="v:verbose,t:trace,f:force,n:num-files,s:size,c:copy,r:remove,a:archive-dir,z:compress,b:background,d:delay,p:pad,o:owner,g:group,m:mode,M:migrate,P:prolog,E:epilog"
        opt_v=no
        opt_t=no
        opt_f=no
        opt_n=10
        opt_s=""
        opt_c=no
        opt_r=no
        opt_a=""
        opt_z=""
        opt_b=no
        opt_d=no
        opt_p=1
        opt_o=""
        opt_g=""
        opt_m=""
        opt_M=""
        opt_P=""
        opt_E=""
        ;;
    tarball )
        str_tool="tarball"
        str_usage="[-t|--trace] [-v|--verbose] [-o|--output <tarball>] [-c|--compress <prog>] [-d|--directory <dir>] [-u|--user <user>] [-g|--group <group>] [-e|--exclude <pattern>] <path> [<path> ...]"
        gen_tmpfile=yes
        arg_spec="1+"
        opt_spec="t.v.o:c:d:u:g:e:"
        opt_alias="t:trace,v:verbose,o:output,c:compress,d:directory,u:user,g:group,e:exclude"
        opt_t=no
        opt_v=no
        opt_o=""
        opt_c=""
        opt_d=""
        opt_u=""
        opt_g=""
        opt_e="CVS,\\.cvsignore,\\.svn,\\.[oa]\$"
        ;;
    subst )
        str_tool="subst"
        str_usage="[-v|--verbose] [-t|--trace] [-n|--nop] [-w|--warning] [-q|--quiet] [-s|--stealth] [-i|--interactive] [-b|--backup <ext>] [-e|--exec <cmd>] [-f|--file <cmd-file>] [<file>] [...]"
        gen_tmpfile=yes
        arg_spec="0+"
        opt_spec="v.t.n.w.q.s.i.b:e+f:"
        opt_alias="v:verbose,t:trace,n:nop,w:warning,q:quiet,s:stealth,i:interactive,b:backup,e:exec,f:file"
        opt_v=no
        opt_t=no
        opt_n=no
        opt_w=no
        opt_q=no
        opt_s=no
        opt_i=no
        opt_b=""
        opt_e=""
        opt_f=""
        ;;
    platform )
        str_tool="platform"
        str_usage="[-F|--format <format>] [-S|--sep <string>] [-C|--conc <string>] [-L|--lower] [-U|--upper] [-v|--verbose] [-c|--concise] [-n|--no-newline] [-t|--type <type>] [-V|--version] [-h|--help]"
        arg_spec="0="
        opt_spec="F:S:C:L.U.v.c.n.t:d.V.h."
        opt_alias="F:format,S:sep,C:conc,L:lower,U:upper,v:verbose,c:consise,t:type,n:no-newline,V:version,h:help"
        opt_F="%{sp} (%{ap})"
        opt_S=" "
        opt_C="/"
        opt_L=no
        opt_U=no
        opt_t=""
        opt_v=no
        opt_c=no
        opt_n=no
        opt_V=no
        opt_h=no
        ;;
    arx )
        str_tool="arx"
        str_usage="[-t|--trace] [-C|--command <cmd>] <op> <archive> [<file> ...]"
        arg_spec="2+"
        opt_spec="t.C:"
        opt_alias="t:trace,C:command"
        opt_t=no
        opt_C="ar"
        ;;
    slo )
        str_tool="slo"
        str_usage="[-p|--prefix <str>] -- -L<dir> -l<lib> [-L<dir> -l<lib> ...]"
        arg_spec="1+"
        opt_spec="p:"
        opt_alias="p:prefix"
        opt_p="SLO_"
        ;;
    scpp )
        str_tool="scpp"
        str_usage="[-v|--verbose] [-p|--preserve] [-f|--filter <filter>] [-o|--output <ofile>] [-t|--template <tfile>] [-M|--mark <mark>] [-D|--define <dname>] [-C|--class <cname>] <file> [<file> ...]"
        gen_tmpfile=yes
        arg_spec="1+"
        opt_spec="v.p.f+o:t:M:D:C:"
        opt_alias="v:verbose,p:preserve,f:filter,o:output,t:template,M:mark,D:define,C:class"
        opt_v=no
        opt_p=no
        opt_f=""
        opt_o="lib.h"
        opt_t="lib.h.in"
        opt_M="%%MARK%%"
        opt_D="cpp"
        opt_C="intern"
        ;;
    version )
        str_tool="version"
        str_usage="[-l|--language <lang>] [-n|--name <name>] [-p|--prefix <prefix>] [-s|--set <version>] [-e|--edit] [-i|--increase <knob>] [-d|--display <type>] <file>"
        arg_spec="1="
        opt_spec="l:n:p:s:i:e.d:"
        opt_alias="l:language,n:name,p:prefix,s:set,e:edit,i:increase,d:display"
        opt_l="txt"
        opt_n="unknown"
        opt_p=""
        opt_s=""
        opt_e="no"
        opt_i=""
        opt_d="short"
        ;;
    path )
        str_tool="path"
        str_usage="[-s|--suppress] [-r|--reverse] [-d|--dirname] [-b|--basename] [-m|--magic] [-p|--path <path>] <str> [<str> ...]"
        gen_tmpfile=yes
        arg_spec="1+"
        opt_spec="s.r.d.b.m.p:"
        opt_alias="s:suppress,r:reverse,d:dirname,b:basename,m:magic,p:path"
        opt_s=no
        opt_r=no
        opt_d=no
        opt_b=no
        opt_m=no
        opt_p="$PATH"
        ;;
    -* )
        echo "$0:Error: unknown option \`$tool'" 2>&1
        echo "$0:Hint:  run \`$0 -h' for usage" 2>&1
        exit 1
        ;;
    * )
        echo "$0:Error: unknown command \`$tool'" 2>&1
        echo "$0:Hint:  run \`$0 -h' for usage" 2>&1
        exit 1
        ;;
esac

##
##  COMMON UTILITY CODE
##

#   commonly used ASCII values
ASC_TAB="	"
ASC_NL="
"

#   determine name of tool
if [ ".$tool" != . ]; then
    #   used inside shtool script
    toolcmd="$0 $tool"
    toolcmdhelp="shtool $tool"
    msgprefix="shtool:$tool"
else
    #   used as standalone script
    toolcmd="$0"
    toolcmdhelp="sh $0"
    msgprefix="$str_tool"
fi

#   parse argument specification string
eval `echo $arg_spec |\
      sed -e 's/^\([0-9]*\)\([+=]\)/arg_NUMS=\1; arg_MODE=\2/'`

#   parse option specification string
eval `echo h.$opt_spec |\
      sed -e 's/\([a-zA-Z0-9]\)\([.:+]\)/opt_MODE_\1=\2;/g'`

#   parse option alias string
eval `echo h:help,$opt_alias |\
      sed -e 's/-/_/g' -e 's/\([a-zA-Z0-9]\):\([^,]*\),*/opt_ALIAS_\2=\1;/g'`

#   interate over argument line
opt_PREV=''
while [ $# -gt 0 ]; do
    #   special option stops processing
    if [ ".$1" = ".--" ]; then
        shift
        break
    fi

    #   determine option and argument
    opt_ARG_OK=no
    if [ ".$opt_PREV" != . ]; then
        #   merge previous seen option with argument
        opt_OPT="$opt_PREV"
        opt_ARG="$1"
        opt_ARG_OK=yes
        opt_PREV=''
    else
        #   split argument into option and argument
        case "$1" in
            --[a-zA-Z0-9]*=*)
                eval `echo "x$1" |\
                      sed -e 's/^x--\([a-zA-Z0-9-]*\)=\(.*\)$/opt_OPT="\1";opt_ARG="\2"/'`
                opt_STR=`echo $opt_OPT | sed -e 's/-/_/g'`
                eval "opt_OPT=\${opt_ALIAS_${opt_STR}-${opt_OPT}}"
                ;;
            --[a-zA-Z0-9]*)
                opt_OPT=`echo "x$1" | cut -c4-`
                opt_STR=`echo $opt_OPT | sed -e 's/-/_/g'`
                eval "opt_OPT=\${opt_ALIAS_${opt_STR}-${opt_OPT}}"
                opt_ARG=''
                ;;
            -[a-zA-Z0-9]*)
                eval `echo "x$1" |\
                      sed -e 's/^x-\([a-zA-Z0-9]\)/opt_OPT="\1";/' \
                          -e 's/";\(.*\)$/"; opt_ARG="\1"/'`
                ;;
            -[a-zA-Z0-9])
                opt_OPT=`echo "x$1" | cut -c3-`
                opt_ARG=''
                ;;
            *)
                break
                ;;
        esac
    fi

    #   eat up option
    shift

    #   determine whether option needs an argument
    eval "opt_MODE=\$opt_MODE_${opt_OPT}"
    if [ ".$opt_ARG" = . ] && [ ".$opt_ARG_OK" != .yes ]; then
        if [ ".$opt_MODE" = ".:" ] || [ ".$opt_MODE" = ".+" ]; then
            opt_PREV="$opt_OPT"
            continue
        fi
    fi

    #   process option
    case $opt_MODE in
        '.' )
            #   boolean option
            eval "opt_${opt_OPT}=yes"
            ;;
        ':' )
            #   option with argument (multiple occurances override)
            eval "opt_${opt_OPT}=\"\$opt_ARG\""
            ;;
        '+' )
            #   option with argument (multiple occurances append)
            eval "opt_${opt_OPT}=\"\$opt_${opt_OPT}\${ASC_NL}\$opt_ARG\""
            ;;
        * )
            echo "$msgprefix:Error: unknown option: \`$opt_OPT'" 1>&2
            echo "$msgprefix:Hint:  run \`$toolcmdhelp -h' or \`man shtool' for details" 1>&2
            exit 1
            ;;
    esac
done
if [ ".$opt_PREV" != . ]; then
    echo "$msgprefix:Error: missing argument to option \`$opt_PREV'" 1>&2
    echo "$msgprefix:Hint:  run \`$toolcmdhelp -h' or \`man shtool' for details" 1>&2
    exit 1
fi

#   process help option
if [ ".$opt_h" = .yes ]; then
    echo "Usage: $toolcmdhelp $str_usage"
    exit 0
fi

#   complain about incorrect number of arguments
case $arg_MODE in
    '=' )
        if [ $# -ne $arg_NUMS ]; then
            echo "$msgprefix:Error: invalid number of arguments (exactly $arg_NUMS expected)" 1>&2
            echo "$msgprefix:Hint:  run \`$toolcmd -h' or \`man shtool' for details" 1>&2
            exit 1
        fi
        ;;
    '+' )
        if [ $# -lt $arg_NUMS ]; then
            echo "$msgprefix:Error: invalid number of arguments (at least $arg_NUMS expected)" 1>&2
            echo "$msgprefix:Hint:  run \`$toolcmd -h' or \`man shtool' for details" 1>&2
            exit 1
        fi
        ;;
esac

#   establish a temporary file on request
if [ ".$gen_tmpfile" = .yes ]; then
    #   create (explicitly) secure temporary directory
    if [ ".$TMPDIR" != . ]; then
        tmpdir="$TMPDIR"
    elif [ ".$TEMPDIR" != . ]; then
        tmpdir="$TEMPDIR"
    else
        tmpdir="/tmp"
    fi
    tmpdir="$tmpdir/.shtool.$$"
    ( umask 077
      rm -rf "$tmpdir" >/dev/null 2>&1 || true
      mkdir  "$tmpdir" >/dev/null 2>&1
      if [ $? -ne 0 ]; then
          echo "$msgprefix:Error: failed to create temporary directory \`$tmpdir'" 1>&2
          exit 1
      fi
    )

    #   create (implicitly) secure temporary file
    tmpfile="$tmpdir/shtool.tmp"
    touch "$tmpfile"
fi

#   utility function: map string to lower case
util_lower () {
    echo "$1" | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'
}

#   utility function: map string to upper case
util_upper () {
    echo "$1" | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
}

#   cleanup procedure
shtool_exit () {
    rc="$1"
    if [ ".$gen_tmpfile" = .yes ]; then
        rm -rf "$tmpdir" >/dev/null 2>&1 || true
    fi
    exit $rc
}

##
##  DISPATCH INTO SCRIPT BODY
##

case $tool in

echo )
    ##
    ##  echo -- Print string with optional construct expansion
    ##  Copyright (c) 1998-2008 Ralf S. Engelschall <rse@engelschall.com>
    ##

    text="$*"

    #   check for broken escape sequence expansion
    seo=''
    bytes=`echo '\1' | wc -c | awk '{ printf("%s", $1); }'`
    if [ ".$bytes" != .3 ]; then
        bytes=`echo -E '\1' | wc -c | awk '{ printf("%s", $1); }'`
        if [ ".$bytes" = .3 ]; then
            seo='-E'
        fi
    fi

    #   check for existing -n option (to suppress newline)
    minusn=''
    bytes=`echo -n 123 2>/dev/null | wc -c | awk '{ printf("%s", $1); }'`
    if [ ".$bytes" = .3 ]; then
        minusn='-n'
    fi

    #   determine terminal bold sequence
    term_bold=''
    term_norm=''
    if [ ".$opt_e" = .yes ] && [ ".`echo $text | grep '%[Bb]'`" != . ]; then
        case $TERM in
            #   for the most important terminal types we directly know the sequences
            xterm|xterm*|vt220|vt220*)
                term_bold=`awk 'BEGIN { printf("%c%c%c%c", 27, 91, 49, 109); }' </dev/null 2>/dev/null`
                term_norm=`awk 'BEGIN { printf("%c%c%c", 27, 91, 109); }' </dev/null 2>/dev/null`
                ;;
            vt100|vt100*|cygwin)
                term_bold=`awk 'BEGIN { printf("%c%c%c%c%c%c", 27, 91, 49, 109, 0, 0); }' </dev/null 2>/dev/null`
                term_norm=`awk 'BEGIN { printf("%c%c%c%c%c", 27, 91, 109, 0, 0); }' </dev/null 2>/dev/null`
                ;;
            #   for all others, we try to use a possibly existing `tput' or `tcout' utility
            * )
                paths=`echo $PATH | sed -e 's/:/ /g'`
                for tool in tput tcout; do
                    for dir in $paths; do
                        if [ -r "$dir/$tool" ]; then
                            for seq in bold md smso; do # 'smso' is last
                                bold="`$dir/$tool $seq 2>/dev/null`"
                                if [ ".$bold" != . ]; then
                                    term_bold="$bold"
                                    break
                                fi
                            done
                            if [ ".$term_bold" != . ]; then
                                for seq in sgr0 me rmso init reset; do # 'reset' is last
                                    norm="`$dir/$tool $seq 2>/dev/null`"
                                    if [ ".$norm" != . ]; then
                                        term_norm="$norm"
                                        break
                                    fi
                                done
                            fi
                            break
                        fi
                    done
                    if [ ".$term_bold" != . ] && [ ".$term_norm" != . ]; then
                        break;
                    fi
                done
                ;;
        esac
        if [ ".$term_bold" = . ] || [ ".$term_norm" = . ]; then
            echo "$msgprefix:Warning: unable to determine terminal sequence for bold mode" 1>&2
            term_bold=''
            term_norm=''
        fi
    fi

    #   determine user name
    username=''
    if [ ".$opt_e" = .yes ] && [ ".`echo $text | grep '%[uUgG]'`" != . ]; then
        username="`(id -un) 2>/dev/null`"
        if [ ".$username" = . ]; then
            str="`(id) 2>/dev/null`"
            if [ ".`echo $str | grep '^uid[ 	]*=[ 	]*[0-9]*('`" != . ]; then
                username=`echo $str | sed -e 's/^uid[ 	]*=[ 	]*[0-9]*(//' -e 's/).*$//'`
            fi
            if [ ".$username" = . ]; then
                username="$LOGNAME"
                if [ ".$username" = . ]; then
                    username="$USER"
                    if [ ".$username" = . ]; then
                        username="`(whoami) 2>/dev/null |\
                                   awk '{ printf("%s", $1); }'`"
                        if [ ".$username" = . ]; then
                            username="`(who am i) 2>/dev/null |\
                                       awk '{ printf("%s", $1); }'`"
                            if [ ".$username" = . ]; then
                                username='unknown'
                            fi
                        fi
                    fi
                fi
            fi
        fi
    fi

    #   determine user id
    userid=''
    if [ ".$opt_e" = .yes ] && [ ".`echo $text | grep '%U'`" != . ]; then
        userid="`(id -u) 2>/dev/null`"
        if [ ".$userid" = . ]; then
            userid="`(id -u ${username}) 2>/dev/null`"
            if [ ".$userid" = . ]; then
                str="`(id) 2>/dev/null`"
                if [ ".`echo $str | grep '^uid[ 	]*=[ 	]*[0-9]*('`" != . ]; then
                    userid=`echo $str | sed -e 's/^uid[ 	]*=[ 	]*//' -e 's/(.*$//'`
                fi
                if [ ".$userid" = . ]; then
                    userid=`(getent passwd ${username}) 2>/dev/null | \
                            sed -e 's/[^:]*:[^:]*://' -e 's/:.*$//'`
                    if [ ".$userid" = . ]; then
                        userid=`grep "^${username}:" /etc/passwd 2>/dev/null | \
                                sed -e 's/[^:]*:[^:]*://' -e 's/:.*$//'`
                        if [ ".$userid" = . ]; then
                            userid=`(ypmatch "${username}" passwd; nismatch "${username}" passwd) 2>/dev/null | \
                                    sed -e 'q' | sed -e 's/[^:]*:[^:]*://' -e 's/:.*$//'`
                            if [ ".$userid" = . ]; then
                                userid=`(nidump passwd . | grep "^${username}:") 2>/dev/null | \
                                        sed -e 's/[^:]*:[^:]*://' -e 's/:.*$//'`
                                if [ ".$userid" = . ]; then
                                    userid='?'
                                fi
                            fi
                        fi
                    fi
                fi
            fi
        fi
    fi

    #   determine (primary) group id
    groupid=''
    if [ ".$opt_e" = .yes ] && [ ".`echo $text | grep '%[gG]'`" != . ]; then
        groupid="`(id -g ${username}) 2>/dev/null`"
        if [ ".$groupid" = . ]; then
            str="`(id) 2>/dev/null`"
            if [ ".`echo $str | grep 'gid[ 	]*=[ 	]*[0-9]*('`" != . ]; then
                groupid=`echo $str | sed -e 's/^.*gid[ 	]*=[ 	]*//' -e 's/(.*$//'`
            fi
            if [ ".$groupid" = . ]; then
                groupid=`(getent passwd ${username}) 2>/dev/null | \
                         sed -e 's/[^:]*:[^:]*:[^:]*://' -e 's/:.*$//'`
                if [ ".$groupid" = . ]; then
                    groupid=`grep "^${username}:" /etc/passwd 2>/dev/null | \
                             sed -e 's/[^:]*:[^:]*:[^:]*://' -e 's/:.*$//'`
                    if [ ".$groupid" = . ]; then
                        groupid=`(ypmatch "${username}" passwd; nismatch "${username}" passwd) 2>/dev/null | \
                                 sed -e 'q' | sed -e 's/[^:]*:[^:]*:[^:]*://' -e 's/:.*$//'`
                        if [ ".$groupid" = . ]; then
                            groupid=`(nidump passwd . | grep "^${username}:") 2>/dev/null | \
                                     sed -e 's/[^:]*:[^:]*:[^:]*://' -e 's/:.*$//'`
                            if [ ".$groupid" = . ]; then
                                groupid='?'
                            fi
                        fi
                    fi
                fi
            fi
        fi
    fi

    #   determine (primary) group name
    groupname=''
    if [ ".$opt_e" = .yes ] && [ ".`echo $text | grep '%g'`" != . ]; then
        groupname="`(id -gn ${username}) 2>/dev/null`"
        if [ ".$groupname" = . ]; then
            str="`(id) 2>/dev/null`"
            if [ ".`echo $str | grep 'gid[ 	]*=[ 	]*[0-9]*('`" != . ]; then
                groupname=`echo $str | sed -e 's/^.*gid[ 	]*=[ 	]*[0-9]*(//' -e 's/).*$//'`
            fi
            if [ ".$groupname" = . ]; then
                groupname=`(getent group) 2>/dev/null | \
                           grep "^[^:]*:[^:]*:${groupid}:" | \
                           sed -e 's/:.*$//'`
                if [ ".$groupname" = . ]; then
                    groupname=`grep "^[^:]*:[^:]*:${groupid}:" /etc/group 2>/dev/null | \
                               sed -e 's/:.*$//'`
                    if [ ".$groupname" = . ]; then
                        groupname=`(ypcat group; niscat group) 2>/dev/null | \
                                   sed -e 'q' | grep "^[^:]*:[^:]*:${groupid}:" | \
                                   sed -e 's/:.*$//'`
                        if [ ".$groupname" = . ]; then
                            groupname=`(nidump group .) 2>/dev/null | \
                                       grep "^[^:]*:[^:]*:${groupid}:" | \
                                       sed -e 's/:.*$//'`
                            if [ ".$groupname" = . ]; then
                                groupname='?'
                            fi
                        fi
                    fi
                fi
            fi
        fi
    fi

    #   determine host and domain name
    hostname=''
    domainname=''
    if [ ".$opt_e" = .yes ] && [ ".`echo $text | grep '%h'`" != . ]; then
        hostname="`(uname -n) 2>/dev/null |\
                   awk '{ printf("%s", $1); }'`"
        if [ ".$hostname" = . ]; then
            hostname="`(hostname) 2>/dev/null |\
                       awk '{ printf("%s", $1); }'`"
            if [ ".$hostname" = . ]; then
                hostname='unknown'
            fi
        fi
        case $hostname in
            *.* )
                domainname=".`echo $hostname | cut -d. -f2-`"
                hostname="`echo $hostname | cut -d. -f1`"
                ;;
        esac
    fi
    if [ ".$opt_e" = .yes ] && [ ".`echo $text | grep '%d'`" != . ]; then
        if [ ".$domainname" = . ]; then
            if [ -f /etc/resolv.conf ]; then
                domainname="`grep '^[ 	]*domain' /etc/resolv.conf | sed -e 'q' |\
                             sed -e 's/.*domain//' \
                                 -e 's/^[ 	]*//' -e 's/^ *//' -e 's/^	*//' \
                                 -e 's/^\.//' -e 's/^/./' |\
                             awk '{ printf("%s", $1); }'`"
                if [ ".$domainname" = . ]; then
                    domainname="`grep '^[ 	]*search' /etc/resolv.conf | sed -e 'q' |\
                                 sed -e 's/.*search//' \
                                     -e 's/^[ 	]*//' -e 's/^ *//' -e 's/^	*//' \
                                     -e 's/ .*//' -e 's/	.*//' \
                                     -e 's/^\.//' -e 's/^/./' |\
                                 awk '{ printf("%s", $1); }'`"
                fi
            fi
        fi
    fi

    #   determine current time
    time_day=''
    time_month=''
    time_year=''
    time_monthname=''
    if [ ".$opt_e" = .yes ] && [ ".`echo $text | grep '%[DMYm]'`" != . ]; then
        time_day=`date '+%d'`
        time_month=`date '+%m'`
        time_year=`date '+%Y' 2>/dev/null`
        if [ ".$time_year" = . ]; then
            time_year=`date '+%y'`
            case $time_year in
                [5-9][0-9]) time_year="19$time_year" ;;
                [0-4][0-9]) time_year="20$time_year" ;;
            esac
        fi
        case $time_month in
            1|01) time_monthname='Jan' ;;
            2|02) time_monthname='Feb' ;;
            3|03) time_monthname='Mar' ;;
            4|04) time_monthname='Apr' ;;
            5|05) time_monthname='May' ;;
            6|06) time_monthname='Jun' ;;
            7|07) time_monthname='Jul' ;;
            8|08) time_monthname='Aug' ;;
            9|09) time_monthname='Sep' ;;
              10) time_monthname='Oct' ;;
              11) time_monthname='Nov' ;;
              12) time_monthname='Dec' ;;
        esac
    fi

    #   expand special ``%x'' constructs
    if [ ".$opt_e" = .yes ]; then
        text=`echo $seo "$text" |\
              sed -e "s/%B/${term_bold}/g" \
                  -e "s/%b/${term_norm}/g" \
                  -e "s/%u/${username}/g" \
                  -e "s/%U/${userid}/g" \
                  -e "s/%g/${groupname}/g" \
                  -e "s/%G/${groupid}/g" \
                  -e "s/%h/${hostname}/g" \
                  -e "s/%d/${domainname}/g" \
                  -e "s/%D/${time_day}/g" \
                  -e "s/%M/${time_month}/g" \
                  -e "s/%Y/${time_year}/g" \
                  -e "s/%m/${time_monthname}/g" 2>/dev/null`
    fi

    #   create output
    if [ .$opt_n = .no ]; then
        echo $seo "$text"
    else
        #   the harder part: echo -n is best, because
        #   awk may complain about some \xx sequences.
        if [ ".$minusn" != . ]; then
            echo $seo $minusn "$text"
        else
            echo dummy | awk '{ printf("%s", TEXT); }' TEXT="$text"
        fi
    fi

    shtool_exit 0
    ;;

mdate )
    ##
    ##  mdate -- Pretty-print modification time of a file or dir
    ##  Copyright (c) 1995-1997 Free Software Foundation, Inc.
    ##  Copyright (c) 1998-2008 Ralf S. Engelschall <rse@engelschall.com>
    ##

    fod="$1"
    case "$opt_o" in
        [dmy][dmy][dmy] )
            ;;
        * ) echo "$msgprefix:Error: invalid argument to option \`-o': $opt_o" 1>&2
            shtool_exit 1
            ;;
    esac
    if [ ! -r "$fod" ]; then
        echo "$msgprefix:Error: file or directory not found: $fod" 1>&2
        shtool_exit 1
    fi

    #   GNU ls changes its time format in response to the TIME_STYLE
    #   variable. Since we cannot assume "unset" works, revert this
    #   variable to its documented default.
    if [ ".$TIME_STYLE" != . ]; then
        TIME_STYLE=posix-long-iso
        export TIME_STYLE
    fi

    #   get the extended ls output of the file or directory.
    if /bin/ls -L /dev/null >/dev/null 2>&1; then
        set - x`/bin/ls -L -l -d $fod`
    else
        set - x`/bin/ls -l -d $fod`
    fi

    #   The month is at least the fourth argument
    #   (3 shifts here, the next inside the loop).
    shift; shift; shift

    #   Find the month. Next argument is day, followed by the year or time.
    month=""
    while [ ".$month" = . ]; do
        shift
        case $1 in
            Jan) month=January;   nummonth=1  ;;
            Feb) month=February;  nummonth=2  ;;
            Mar) month=March;     nummonth=3  ;;
            Apr) month=April;     nummonth=4  ;;
            May) month=May;       nummonth=5  ;;
            Jun) month=June;      nummonth=6  ;;
            Jul) month=July;      nummonth=7  ;;
            Aug) month=August;    nummonth=8  ;;
            Sep) month=September; nummonth=9  ;;
            Oct) month=October;   nummonth=10 ;;
            Nov) month=November;  nummonth=11 ;;
            Dec) month=December;  nummonth=12 ;;
        esac
    done
    day="$2"
    year="$3"

    #   We finally have to deal with the problem that the "ls" output
    #   gives either the time of the day or the year.
    case $year in
        *:*)
            this_year=`date '+%Y' 2>/dev/null`
            if [ ".$this_year" = . ]; then
                this_year=`date '+%y'`
                case $this_year in
                    [5-9][0-9]) this_year="19$this_year" ;;
                    [0-4][0-9]) this_year="20$this_year" ;;
                esac
            fi
            #   for the following months of the last year the time notation
            #   is usually also used for files modified in the last year.
            this_month=`date '+%m'`
            if (expr $nummonth \> $this_month) >/dev/null; then
                this_year=`expr $this_year - 1`
            fi
            year="$this_year"
            ;;
    esac

    #   Optionally fill day and month with leeding zeros
    if [ ".$opt_z" = .yes ]; then
        case $day in
            [0-9][0-9] ) ;;
                 [0-9] ) day="0$day" ;;
        esac
        case $nummonth in
            [0-9][0-9] ) ;;
                 [0-9] ) nummonth="0$nummonth" ;;
        esac
    fi

    #   Optionally use digits for month
    if [ ".$opt_d" = .yes ]; then
        month="$nummonth"
    fi

    #   Optionally shorten the month name to three characters
    if [ ".$opt_s" = .yes ]; then
        month=`echo $month | cut -c1-3`
    fi

    #   Output the resulting date string
    echo dummy | awk '{
        for (i = 0; i < 3; i++) {
            now = substr(order, 1, 1);
            order = substr(order, 2);
            if (now == "d")
                out = day;
            else if (now == "m")
                out = month;
            else if (now == "y")
                out = year;
            if (i < 2)
                printf("%s%s", out, field);
            else
                printf("%s", out);
        }
        if (newline != "yes")
            printf("\n");
    }' "day=$day" "month=$month" "year=$year" \
       "field=$opt_f" "order=$opt_o" "newline=$opt_n"

    shtool_exit 0
    ;;

table )
    ##
    ##  table -- Pretty-print a field-separated list as a table
    ##  Copyright (c) 1998-2008 Ralf S. Engelschall <rse@engelschall.com>
    ##

    if [ $opt_c -gt 4 ]; then
        echo "$msgprefix:Error: Invalid number of colums (1..4 allowed only)" 1>&2
        shtool_exit 1
    fi
    case "x$opt_F" in
        x? ) ;;
        *  ) echo "$msgprefix:Error: Invalid separator (one char allowed only)" 1>&2; shtool_exit 1 ;;
    esac

    #   split the list into a table
    list=`
        IFS="$opt_F"
        for entry in $*; do
            if [ ".$entry" != . ]; then
                echo "$entry"
            fi
        done |\
        awk "
            BEGIN { list = \"\"; n = 0; }
            {
                list = list \\$1;
                n = n + 1;
                if (n < $opt_c) {
                    list = list \":\";
                }
                if (n == $opt_c) {
                    list = list \"\\n\";
                    n = 0;
                }
            }
            END { print list; }
         "
    `

    #   format table cells and make sure table
    #   doesn't exceed maximum width
    OIFS="$IFS"
    IFS='
'
    for entry in $list; do
        case $opt_c in
            1 ) eval "echo \"\${entry}\" | awk -F: '{ printf(\"%-${opt_w}s\\n\", \$1); }'" ;;
            2 ) eval "echo \"\${entry}\" | awk -F: '{ printf(\"%-${opt_w}s %-${opt_w}s\\n\", \$1, \$2); }'" ;;
            3 ) eval "echo \"\${entry}\" | awk -F: '{ printf(\"%-${opt_w}s %-${opt_w}s %-${opt_w}s\\n\", \$1, \$2, \$3); }'" ;;
            4 ) eval "echo \"\${entry}\" | awk -F: '{ printf(\"%-${opt_w}s %-${opt_w}s %-${opt_w}s %-${opt_w}s\\n\", \$1, \$2, \$3, \$4); }'" ;;
        esac
    done |\
    awk "{
        if (length(\$0) > $opt_s) {
            printf(\"%s\\n\", substr(\$0, 0, $opt_s-1));
        } else {
            print \$0;
        }
    }"
    IFS="$OIFS"

    shtool_exit 0
    ;;

prop )
    ##
    ##  prop -- Display progress with a running propeller
    ##  Copyright (c) 1998-2008 Ralf S. Engelschall <rse@engelschall.com>
    ##

    perl=''
    for dir in `echo $PATH | sed -e 's/:/ /g'` .; do
        if [ -f "$dir/perl" ]; then
            perl="$dir/perl"
            break
        fi
    done
    if [ ".$perl" != . ]; then
        #   Perl is preferred because writing to STDERR in
        #   Perl really writes immediately as one would expect
        $perl -e '
            @p = ("|","/","-","\\");
            $i = 0;
            while (<STDIN>) {
                printf(STDERR "\r%s...%s\b", $ARGV[0], $p[$i++]);
                $i = 0 if ($i > 3);
            }
            printf(STDERR "\r%s    \n", $ARGV[0]);
        ' "$opt_p"
    else
        #   But if Perl doesn't exists we use Awk even
        #   some Awk's buffer even the /dev/stderr writing :-(
        awk '
            BEGIN {
                split("|#/#-#\\", p, "#");
                i = 1;
            }
            {
                printf("\r%s%c\b", prefix, p[i++]) > "/dev/stderr";
                if (i > 4) { i = 1; }
            }
            END {
                printf("\r%s    \n", prefix) > "/dev/stderr";
            }
        ' "prefix=$opt_p"
    fi

    shtool_exit 0
    ;;

move )
    ##
    ##  move -- Move files with simultaneous substitution
    ##  Copyright (c) 1999-2008 Ralf S. Engelschall <rse@engelschall.com>
    ##

    src="$1"
    dst="$2"

    #   consistency checks
    if [ ".$src" = . ] || [ ".$dst" = . ]; then
        echo "$msgprefix:Error: Invalid arguments" 1>&2
        shtool_exit 1
    fi
    if [ ".$src" = ".$dst" ]; then
        echo "$msgprefix:Error: Source and destination files are the same" 1>&2
        shtool_exit 1
    fi
    expsrc="$src"
    if [ ".$opt_e" = .yes ]; then
        expsrc="`echo $expsrc`"
    fi
    if [ ".$opt_e" = .yes ]; then
        if [ ".`echo "$src" | sed -e 's;^.*\\*.*$;;'`" = ".$src" ]; then
            echo "$msgprefix:Error: Source doesn't contain wildcard ('*'): $dst" 1>&2
            shtool_exit 1
        fi
        if [ ".`echo "$dst" | sed -e 's;^.*%[1-9].*$;;'`" = ".$dst" ]; then
            echo "$msgprefix:Error: Destination doesn't contain substitution ('%N'): $dst" 1>&2
            shtool_exit 1
        fi
        if [ ".$expsrc" = ".$src" ]; then
            echo "$msgprefix:Error: Sources not found or no asterisk : $src" 1>&2
            shtool_exit 1
        fi
    else
        if [ ! -r "$src" ]; then
            echo "$msgprefix:Error: Source not found: $src" 1>&2
            shtool_exit 1
        fi
    fi

    #   determine substitution patterns
    if [ ".$opt_e" = .yes ]; then
        srcpat=`echo "$src" | sed -e 's/\\./\\\\./g' -e 's/;/\\;/g' -e 's;\\*;\\\\(.*\\\\);g'`
        dstpat=`echo "$dst" | sed -e 's;%\([1-9]\);\\\\\1;g'`
    fi

    #   iterate over source(s)
    for onesrc in $expsrc; do
        if [ .$opt_e = .yes ]; then
            onedst=`echo $onesrc | sed -e "s;$srcpat;$dstpat;"`
        else
            onedst="$dst"
        fi
        errorstatus=0
        if [ ".$opt_v" = .yes ]; then
            echo "$onesrc -> $onedst"
        fi
        if [ ".$opt_p" = .yes ]; then
            if [ -r $onedst ]; then
                if cmp -s $onesrc $onedst; then
                    if [ ".$opt_t" = .yes ]; then
                        echo "rm -f $onesrc" 1>&2
                    fi
                    rm -f $onesrc || errorstatus=$?
                else
                    if [ ".$opt_t" = .yes ]; then
                        echo "mv -f $onesrc $onedst" 1>&2
                    fi
                    mv -f $onesrc $onedst || errorstatus=$?
                fi
            else
                if [ ".$opt_t" = .yes ]; then
                    echo "mv -f $onesrc $onedst" 1>&2
                fi
                mv -f $onesrc $onedst || errorstatus=$?
            fi
        else
            if [ ".$opt_t" = .yes ]; then
                echo "mv -f $onesrc $onedst" 1>&2
            fi
            mv -f $onesrc $onedst || errorstatus=$?
        fi
        if [ $errorstatus -ne 0 ]; then
            break;
        fi
    done

    shtool_exit $errorstatus
    ;;

install )
    ##
    ##  install -- Install a program, script or datafile
    ##  Copyright (c) 1997-2008 Ralf S. Engelschall <rse@engelschall.com>
    ##

    #   special case: "shtool install -d <dir> [...]" internally
    #   maps to "shtool mkdir -f -p -m 755 <dir> [...]"
    if [ "$opt_d" = yes ]; then
        cmd="$0 mkdir -f -p -m 755"
        if [ ".$opt_o" != . ]; then
            cmd="$cmd -o '$opt_o'"
        fi
        if [ ".$opt_g" != . ]; then
            cmd="$cmd -g '$opt_g'"
        fi
        if [ ".$opt_v" = .yes ]; then
            cmd="$cmd -v"
        fi
        if [ ".$opt_t" = .yes ]; then
            cmd="$cmd -t"
        fi
        for dir in "$@"; do
            eval "$cmd $dir" || shtool_exit $?
        done
        shtool_exit 0
    fi

    #   determine source(s) and destination
    argc=$#
    srcs=""
    while [ $# -gt 1 ]; do
        srcs="$srcs $1"
        shift
    done
    dstpath="$1"

    #   type check for destination
    dstisdir=0
    if [ -d $dstpath ]; then
        dstpath=`echo "$dstpath" | sed -e 's:/$::'`
        dstisdir=1
    fi

    #   consistency check for destination
    if [ $argc -gt 2 ] && [ $dstisdir = 0 ]; then
        echo "$msgprefix:Error: multiple sources require destination to be directory" 1>&2
        shtool_exit 1
    fi

    #   iterate over all source(s)
    for src in $srcs; do
        dst=$dstpath

        #   if destination is a directory, append the input filename
        if [ $dstisdir = 1 ]; then
            dstfile=`echo "$src" | sed -e 's;.*/\([^/]*\)$;\1;'`
            dst="$dst/$dstfile"
        fi

        #   check for correct arguments
        if [ ".$src" = ".$dst" ]; then
            echo "$msgprefix:Warning: source and destination are the same - skipped" 1>&2
            continue
        fi
        if [ -d "$src" ]; then
            echo "$msgprefix:Warning: source \`$src' is a directory - skipped" 1>&2
            continue
        fi

        #   make a temp file name in the destination directory
        dsttmp=`echo $dst |\
                sed -e 's;[^/]*$;;' -e 's;\(.\)/$;\1;' -e 's;^$;.;' \
                    -e "s;\$;/#INST@$$#;"`

        #   verbosity
        if [ ".$opt_v" = .yes ]; then
            echo "$src -> $dst" 1>&2
        fi

        #   copy or move the file name to the temp name
        #   (because we might be not allowed to change the source)
        if [ ".$opt_C" = .yes ]; then
            opt_c=yes
        fi
        if [ ".$opt_c" = .yes ]; then
            if [ ".$opt_t" = .yes ]; then
                echo "cp $src $dsttmp" 1>&2
            fi
            cp "$src" "$dsttmp" || shtool_exit $?
        else
            if [ ".$opt_t" = .yes ]; then
                echo "mv $src $dsttmp" 1>&2
            fi
            mv "$src" "$dsttmp" || shtool_exit $?
        fi

        #   adjust the target file
        if [ ".$opt_e" != . ]; then
            sed='sed'
            OIFS="$IFS"; IFS="$ASC_NL"; set -- $opt_e; IFS="$OIFS"
            for e
            do
                sed="$sed -e '$e'"
            done
            cp "$dsttmp" "$dsttmp.old"
            chmod u+w $dsttmp
            eval "$sed <$dsttmp.old >$dsttmp" || shtool_exit $?
            rm -f $dsttmp.old
        fi
        if [ ".$opt_s" = .yes ]; then
            if [ ".$opt_t" = .yes ]; then
                echo "strip $dsttmp" 1>&2
            fi
            strip $dsttmp || shtool_exit $?
        fi
        if [ ".$opt_o" != . ]; then
            if [ ".$opt_t" = .yes ]; then
                echo "chown $opt_o $dsttmp" 1>&2
            fi
            chown $opt_o $dsttmp || shtool_exit $?
        fi
        if [ ".$opt_g" != . ]; then
            if [ ".$opt_t" = .yes ]; then
                echo "chgrp $opt_g $dsttmp" 1>&2
            fi
            chgrp $opt_g $dsttmp || shtool_exit $?
        fi
        if [ ".$opt_m" != ".-" ]; then
            if [ ".$opt_t" = .yes ]; then
                echo "chmod $opt_m $dsttmp" 1>&2
            fi
            chmod $opt_m $dsttmp || shtool_exit $?
        fi

        #   determine whether to do a quick install
        #   (has to be done _after_ the strip was already done)
        quick=no
        if [ ".$opt_C" = .yes ]; then
            if [ -r $dst ]; then
                if cmp -s "$src" "$dst"; then
                    quick=yes
                fi
            fi
        fi

        #   finally, install the file to the real destination
        if [ $quick = yes ]; then
            if [ ".$opt_t" = .yes ]; then
                echo "rm -f $dsttmp" 1>&2
            fi
            rm -f $dsttmp
        else
            if [ ".$opt_t" = .yes ]; then
                echo "rm -f $dst && mv $dsttmp $dst" 1>&2
            fi
            rm -f $dst && mv $dsttmp $dst
        fi
    done

    shtool_exit 0
    ;;

mkdir )
    ##
    ##  mkdir -- Make one or more directories
    ##  Copyright (c) 1996-2008 Ralf S. Engelschall <rse@engelschall.com>
    ##

    errstatus=0
    for p in ${1+"$@"}; do
        #   if the directory already exists...
        if [ -d "$p" ]; then
            if [ ".$opt_f" = .no ] && [ ".$opt_p" = .no ]; then
                echo "$msgprefix:Error: directory already exists: $p" 1>&2
                errstatus=1
                break
            else
                continue
            fi
        fi
        #   if the directory has to be created...
        if [ ".$opt_p" = .no ]; then
            if [ ".$opt_t" = .yes ]; then
                echo "mkdir $p" 1>&2
            fi
            mkdir $p || errstatus=$?
            if [ ".$opt_o" != . ]; then
                if [ ".$opt_t" = .yes ]; then
                    echo "chown $opt_o $p" 1>&2
                fi
                chown $opt_o $p || errstatus=$?
            fi
            if [ ".$opt_g" != . ]; then
                if [ ".$opt_t" = .yes ]; then
                    echo "chgrp $opt_g $p" 1>&2
                fi
                chgrp $opt_g $p || errstatus=$?
            fi
            if [ ".$opt_m" != . ]; then
                if [ ".$opt_t" = .yes ]; then
                    echo "chmod $opt_m $p" 1>&2
                fi
                chmod $opt_m $p || errstatus=$?
            fi
        else
            #   the smart situation
            set fnord `echo ":$p" |\
                       sed -e 's/^:\//%/' \
                           -e 's/^://' \
                           -e 's/\// /g' \
                           -e 's/^%/\//'`
            shift
            pathcomp=''
            for d in ${1+"$@"}; do
                pathcomp="$pathcomp$d"
                case "$pathcomp" in
                    -* ) pathcomp="./$pathcomp" ;;
                esac
                if [ ! -d "$pathcomp" ]; then
                    if [ ".$opt_t" = .yes ]; then
                        echo "mkdir $pathcomp" 1>&2
                    fi
                    mkdir $pathcomp || {
                        _errstatus=$?
                        [ -d "$pathcomp" ] || errstatus=${_errstatus}
                        unset _errstatus
                    }
                    if [ ".$opt_o" != . ]; then
                        if [ ".$opt_t" = .yes ]; then
                            echo "chown $opt_o $pathcomp" 1>&2
                        fi
                        chown $opt_o $pathcomp || errstatus=$?
                    fi
                    if [ ".$opt_g" != . ]; then
                        if [ ".$opt_t" = .yes ]; then
                            echo "chgrp $opt_g $pathcomp" 1>&2
                        fi
                        chgrp $opt_g $pathcomp || errstatus=$?
                    fi
                    if [ ".$opt_m" != . ]; then
                        if [ ".$opt_t" = .yes ]; then
                            echo "chmod $opt_m $pathcomp" 1>&2
                        fi
                        chmod $opt_m $pathcomp || errstatus=$?
                    fi
                fi
                pathcomp="$pathcomp/"
            done
        fi
    done

    shtool_exit $errstatus
    ;;

mkln )
    ##
    ##  mkln -- Make link with calculation of relative paths
    ##  Copyright (c) 1998-2008 Ralf S. Engelschall <rse@engelschall.com>
    ##

    #   determine source(s) and destination
    args=$#
    srcs=""
    while [ $# -gt 1 ]; do
        srcs="$srcs $1"
        shift
    done
    dst="$1"
    if [ ! -d $dst ]; then
        if [ $args -gt 2 ]; then
            echo "$msgprefix:Error: multiple sources not allowed when target isn't a directory" 1>&2
            shtool_exit 1
        fi
    fi

    #   determine link options
    lnopt=""
    if [ ".$opt_f" = .yes ]; then
        lnopt="$lnopt -f"
    fi
    if [ ".$opt_s" = .yes ]; then
        lnopt="$lnopt -s"
    fi

    #   iterate over sources
    for src in $srcs; do
        #   determine if one of the paths is an absolute path,
        #   because then we _have_ to use an absolute symlink
        oneisabs=0
        srcisabs=0
        dstisabs=0
        case $src in
            /* ) oneisabs=1; srcisabs=1 ;;
        esac
        case $dst in
            /* ) oneisabs=1; dstisabs=1 ;;
        esac

        #   split source and destination into dir and base name
        if [ -d $src ]; then
            srcdir=`echo $src | sed -e 's;/*$;;'`
            srcbase=""
        else
            srcdir=`echo  $src | sed -e 's;^[^/]*$;;' -e 's;^\(.*/\)[^/]*$;\1;' -e 's;\(.\)/$;\1;'`
            srcbase=`echo $src | sed -e 's;.*/\([^/]*\)$;\1;'`
        fi
        if [ -d $dst ]; then
            dstdir=`echo $dst | sed -e 's;/*$;;'`
            dstbase=""
        else
            dstdir=`echo  $dst | sed -e 's;^[^/]*$;;' -e 's;^\(.*/\)[^/]*$;\1;' -e 's;\(.\)/$;\1;'`
            dstbase=`echo $dst | sed -e 's;.*/\([^/]*\)$;\1;'`
        fi

        #   consistency check
        if [ ".$dstdir" != . ]; then
            if [ ! -d $dstdir ]; then
                echo "$msgprefix:Error: destination directory not found: $dstdir" 1>&2
                shtool_exit 1
            fi
        fi

        #   make sure the source is reachable from the destination
        if [ $dstisabs = 1 ]; then
            if [ $srcisabs = 0 ]; then
                if [ ".$srcdir" = . ]; then
                    srcdir="`pwd | sed -e 's;/*$;;'`"
                    srcisabs=1
                    oneisabs=1
                elif [ -d $srcdir ]; then
                    srcdir="`cd $srcdir; pwd | sed -e 's;/*$;;'`"
                    srcisabs=1
                    oneisabs=1
                fi
            fi
        fi

        #   split away a common prefix
        prefix=""
        if [ ".$srcdir" = ".$dstdir" ] && [ ".$srcdir" != . ]; then
            prefix="$srcdir/"
            srcdir=""
            dstdir=""
        else
            while [ ".$srcdir" != . ] && [ ".$dstdir" != . ]; do
                presrc=`echo $srcdir | sed -e 's;^\([^/]*\)/.*;\1;'`
                predst=`echo $dstdir | sed -e 's;^\([^/]*\)/.*;\1;'`
                if [ ".$presrc" != ".$predst" ]; then
                    break
                fi
                prefix="$prefix$presrc/"
                srcdir=`echo $srcdir | sed -e 's;^[^/]*/*;;'`
                dstdir=`echo $dstdir | sed -e 's;^[^/]*/*;;'`
            done
        fi

        #   destination prefix is just the common prefix
        dstpre="$prefix"

        #   determine source prefix which is the reverse directory
        #   step-up corresponding to the destination directory
        srcpre=""
        allow_relative_srcpre=no
        if [ ".$prefix" != . ] && [ ".$prefix" != ./ ]; then
            allow_relative_srcpre=yes
        fi
        if [ $oneisabs = 0 ]; then
            allow_relative_srcpre=yes
        fi
        if [ ".$opt_s" != .yes ]; then
            allow_relative_srcpre=no
        fi
        if [ ".$allow_relative_srcpre" = .yes ]; then
            pl="$dstdir/"
            OIFS="$IFS"; IFS='/'
            for pe in $pl; do
                [ ".$pe" = .  ] && continue
                [ ".$pe" = .. ] && continue
                srcpre="../$srcpre"
            done
            IFS="$OIFS"
        else
            if [ $srcisabs = 1 ]; then
                srcpre="$prefix"
            fi
        fi

        #   determine destination symlink name
        if [ ".$dstbase" = . ]; then
            if [ ".$srcbase" != . ]; then
                dstbase="$srcbase"
            else
                dstbase=`echo "$prefix$srcdir" | sed -e 's;/*$;;' -e 's;.*/\([^/]*\)$;\1;'`
            fi
        fi

        #   now finalize source and destination directory paths
        srcdir=`echo $srcdir | sed -e 's;\([^/]\)$;\1/;'`
        dstdir=`echo $dstdir | sed -e 's;\([^/]\)$;\1/;'`

        #   run the final link command
        if [ ".$opt_t" = .yes ]; then
            echo "ln$lnopt $srcpre$srcdir$srcbase $dstpre$dstdir$dstbase"
        fi
        eval ln$lnopt $srcpre$srcdir$srcbase $dstpre$dstdir$dstbase
    done

    shtool_exit 0
    ;;

mkshadow )
    ##
    ##  mkshadow -- Make a shadow tree through symbolic links
    ##  Copyright (c) 1998-2008 Ralf S. Engelschall <rse@engelschall.com>
    ##

    #   source and destination directory
    src=`echo "$1" | sed -e 's:/$::' -e 's:^\./\(.\):\1:'`
    dst=`echo "$2" | sed -e 's:/$::' -e 's:^\./\(.\):\1:'`

    #   check whether source exists
    if [ ! -d $src ]; then
        echo "$msgprefix:Error: source directory not found: \`$src'" 1>&2
        shtool_exit 1
    fi

    #   determine if one of the paths is an absolute path,
    #   because then we have to use an absolute symlink
    oneisabs=0
    case $src in
        /* ) oneisabs=1 ;;
    esac
    case $dst in
        /* ) oneisabs=1 ;;
    esac

    #   determine reverse directory for destination directory
    dstrevdir=''
    if [ $oneisabs = 0 ]; then
        #   derive reverse path from forward path
        pwd=`pwd`
        OIFS="$IFS"; IFS='/'
        for pe in $dst; do
            if [ "x$pe" = "x.." ]; then
                OIFS2="$IFS"; IFS="$DIFS"
                eval `echo "$pwd" |\
                      sed -e 's:\([^/]*\)$:; dir="\1":' \
                          -e 's:^\(.*\)/[^/]*;:pwd="\1";:'\
                          -e 's:^;:pwd="";:'`
                dstrevdir="$dir/$dstrevdir"
                IFS="$OIFS2"
            else
                dstrevdir="../$dstrevdir"
            fi
        done
        IFS="$OIFS"
    else
        src="`cd $src; pwd`";
    fi

    #   create directory tree at destination
    if [ ! -d $dst ]; then
        if [ ".$opt_t" = .yes ]; then
            echo "mkdir $dst" 1>&2
        fi
        mkdir $dst
    fi
    if [ ".$opt_a" = .yes ]; then
        DIRS=`cd $src; find . -type d -print |\
              sed -e '/^\.$/d' -e 's:^\./::'`
    else
        DIRS=`cd $src; find . -type d -print |\
              sed -e '/\/CVS/d' -e '/^\.$/d' -e 's:^\./::'`
    fi
    for dir in $DIRS; do
        if [ ".$opt_t" = .yes ]; then
            echo "mkdir $dst/$dir" 1>&2
        fi
        mkdir $dst/$dir
    done

    #   fill directory tree with symlinks to files
    if [ ".$opt_a" = .yes ]; then
        FILES="`cd $src; find . -depth -print |\
                sed -e 's/^\.\///'`"
    else
        FILES="`cd $src; find . -depth -print |\
                sed -e '/\.o$/d' -e '/\.a$/d' -e '/\.so$/d' \
                    -e '/\.cvsignore$/d' -e '/\/CVS/d' \
                    -e '/\/\.#/d' -e '/\.orig$/d' \
                    -e 's/^\.\///'`"
    fi
    for file in $FILES; do
         #  don't use `-type f' above for find because of symlinks
         if [ -d "$src/$file" ]; then
             continue
         fi
         basename=`echo $file | sed -e 's:^.*/::'`
         dir=`echo $file | sed -e 's:[^/]*$::' -e 's:/$::' -e 's:$:/:' -e 's:^/$::'`
         from=`echo "$src/$file" | sed -e 's/^\.\///'`
         to="$dst/$dir$basename"
         if [ $oneisabs = 0 ]; then
             if [ ".$dir" != . ]; then
                 subdir=`echo $dir | sed -e 's:/$::'`
                 #   derive reverse path from forward path
                 revdir=''
                 OIFS="$IFS"; IFS='/'
                 for pe in $subdir; do
                     revdir="../$revdir"
                 done
                 IFS="$OIFS"
                 #   finalize from
                 from="$revdir$from"
             fi
             from="$dstrevdir$from"
         fi
         if [ ".$opt_v" = .yes ]; then
             echo "    $to" 1>&2
         fi
         if [ ".$opt_t" = .yes ]; then
             echo "ln -s $from $to" 1>&2
         fi
         ln -s $from $to
    done

    shtool_exit 0
    ;;

fixperm )
    ##
    ##  fixperm -- Fix file permissions inside a source tree
    ##  Copyright (c) 1996-2008 Ralf S. Engelschall <rse@engelschall.com>
    ##

    paths="$*"

    #   check whether the test command supports the -x option
    if [ -x /bin/sh ] 2>/dev/null; then
        minusx="-x"
    else
        minusx="-r"
    fi

    #   iterate over paths
    for p in $paths; do
        for file in `find $p -depth -print`; do
            if [ -f $file ]; then
                if [ $minusx $file ]; then
                    if [ ".$opt_v" = .yes ]; then
                        echo "-rwxr-xr-x $file" 2>&1
                    fi
                    if [ ".$opt_t" = .yes ]; then
                        echo "chmod 755 $file" 2>&1
                    fi
                    chmod 755 $file
                else
                    if [ ".$opt_v" = .yes ]; then
                        echo "-rw-r--r-- $file" 2>&1
                    fi
                    if [ ".$opt_t" = .yes ]; then
                        echo "chmod 644 $file" 2>&1
                    fi
                    chmod 644 $file
                fi
                continue
            fi
            if [ -d $file ]; then
                if [ ".$opt_v" = .yes ]; then
                    echo "drwxr-xr-x $file" 2>&1
                fi
                if [ ".$opt_t" = .yes ]; then
                    echo "chmod 755 $file" 2>&1
                fi
                chmod 755 $file
                continue
            fi
            if [ ".$opt_v" = .yes ]; then
                echo "?????????? $file" 2>&1
            fi
        done
    done

    shtool_exit 0
    ;;

rotate )
    ##
    ##  rotate -- Logfile rotation
    ##  Copyright (c) 2001-2008 Ralf S. Engelschall <rse@engelschall.com>
    ##

    #   make sure we have at least one file to rotate
    if [ ".$opt_n" = .0 ]; then
        echo "$msgprefix:Error: invalid argument \`$opt_n' to option -n." 1>&2
        shtool_exit 1
    fi

    #   canonicalize -s option argument
    if [ ".$opt_s" != . ]; then
        if [ ".`expr $opt_s : '[0-9]*$'`" != .0 ]; then
            :
        elif [ ".`expr $opt_s : '[0-9]*[Kk]$'`" != .0 ]; then
            opt_s=`expr $opt_s : '\([0-9]*\)[Kk]$'`
            opt_s=`expr $opt_s \* 1024`
        elif [ ".`expr $opt_s : '[0-9]*[Mm]$'`" != .0 ]; then
            opt_s=`expr $opt_s : '\([0-9]*\)[Mm]$'`
            opt_s=`expr $opt_s \* 1048576` # 1024*1024
        elif [ ".`expr $opt_s : '[0-9]*[Gg]$'`" != .0 ]; then
            opt_s=`expr $opt_s : '\([0-9]*\)[Gg]$'`
            opt_s=`expr $opt_s \* 1073741824` # 1024*1024*1024
        else
            echo "$msgprefix:Error: invalid argument \`$opt_s' to option -s." 1>&2
            shtool_exit 1
        fi
    fi

    #   option -d/-z consistency
    if [ ".$opt_d" = .yes ] && [ ".$opt_z" = . ]; then
        echo "$msgprefix:Error: option -d requires option -z." 1>&2
        shtool_exit 1
    fi

    #   make sure target directory exists
    if [ ".$opt_a" != . ]; then
        if [ ! -d $opt_a ]; then
            if [ ".$opt_f" = .no ]; then
                echo "$msgprefix:Error: archive directory \`$opt_a' does not exist." 1>&2
                shtool_exit 1
            fi
            mkdir $opt_a || shtool_exit $?
            chmod 755 $opt_a
        fi
        if [ ! -w $opt_a ]; then
            echo "$msgprefix:Error: archive directory \`$opt_a' not writable." 1>&2
            shtool_exit 1
        fi
    fi

    #   determine compression approach
    if [ ".$opt_z" != . ]; then
        comp_lvl="$opt_z"
        comp_prg=""
        case $comp_lvl in
            *:* ) eval `echo $comp_lvl |\
                        sed -e 's%^\(.*\):\(.*\)$%comp_prg="\1"; comp_lvl="\2"%'` ;;
        esac

        #   compression level consistency
        case $comp_lvl in
            [0-9] )
                ;;
            * ) echo "$msgprefix:Error: invalid compression level \`$comp_lvl'" 1>&2
                shtool_exit 1
                ;;
        esac

        #   determine a suitable compression tool
        if [ ".$comp_prg" = . ]; then
            #   check whether the test command supports the -x option
            if [ -x /bin/sh ] 2>/dev/null; then
                minusx="-x"
            else
                minusx="-r"
            fi
            #   search for tools in $PATH
            paths="`echo $PATH |\
                    sed -e 's%/*:%:%g' -e 's%/*$%%' \
                        -e 's/^:/.:/' -e 's/::/:.:/g' -e 's/:$/:./' \
                        -e 's/:/ /g'`"
            for prg in bzip2 gzip compress; do
                for path in $paths; do
                    if [ $minusx "$path/$prg" ] && [ ! -d "$path/$prg" ]; then
                        comp_prg="$prg"
                        break
                    fi
                done
                if [ ".$comp_prg" != . ]; then
                    break
                fi
            done
            if [ ".$comp_prg" = . ]; then
                echo "$msgprefix:Error: no suitable compression tool found in \$PATH" 1>&2
                shtool_exit 1
            fi
        fi

        #   determine standard compression extension
        #   and make sure it is a known tool
        case $comp_prg in
            */bzip2    | bzip2    ) comp_ext="bz2" comp_lvl="-$comp_lvl" ;;
            */gzip     | gzip     ) comp_ext="gz"  comp_lvl="-$comp_lvl" ;;
            */compress | compress ) comp_ext="Z";  comp_lvl=""           ;;
            * ) echo "$msgprefix:Error: tool \`$comp_prg' is not a known compression tool" 1>&2
                shtool_exit 1
                ;;
        esac
        comp_suf=".$comp_ext"
    fi

    #   iterate over all given logfile arguments
    for file in $*; do
        #   make sure the logfile exists
        if [ ! -f $file ]; then
            if [ ".$opt_f" = .yes ]; then
                continue
            fi
            echo "$msgprefix:Error: logfile \`$file' not found" 1>&2
            shtool_exit 1
        fi

        #   determine log directory (where original logfile is placed)
        ldir="."
        case $file in
            */* ) eval `echo $file | sed -e 's%^\(.*\)/\([^/]*\)$%ldir="\1"; file="\2";%'` ;;
        esac

        #   determine archive directory (where rotated logfiles are placed)
        adir="$ldir"
        if [ ".$opt_a" != . ]; then
            case "$opt_a" in
                /* | ./* ) adir="$opt_a" ;;
                * ) adir="$ldir/$opt_a"  ;;
            esac
        fi

        #   optionally take logfile size into account
        if [ ".$opt_s" != . ]; then
            #   determine size of logfile
            set -- `env -i /bin/ls -l "$ldir/$file" | sed -e "s;$ldir/$file;;" |\
                    sed -e 's; -> .*$;;' -e 's;[ 	][ 	]*; ;g'`
            n=`expr $# - 3`
            eval "size=\`echo \${$n}\`"

            #   skip logfile if size is still too small
            if [ $size -lt $opt_s ]; then
                if [ ".$opt_v" = .yes ]; then
                    echo "$ldir/$file: still too small in size -- skipping"
                fi
                continue
            fi
        fi

        #   verbosity
        if [ ".$opt_v" = .yes ]; then
            echo "rotating $ldir/$file"
        fi

        #   execute prolog
        if [ ".$opt_P" != . ]; then
            if [ ".$opt_t" = .yes ]; then
                echo "$opt_P"
            fi
            eval $opt_P
            [ $? -ne 0 ] && shtool_exit $?
        fi

        #   kick away out-rotated logfile
        n=`expr $opt_n - 1`
        n=`echo dummy | awk "{ printf(\"%0${opt_p}d\", n); }" n=$n`
        if [ -f "${adir}/${file}.${n}${comp_suf}" ]; then
            #   optionally migrate away the out-rotated logfile
            if [ ".$opt_M" != . ]; then
                if [ ".$opt_t" = .yes ]; then
                    echo "$opt_M ${adir}/${file}.${n}${comp_suf}"
                fi
                eval "$opt_M ${adir}/${file}.${n}${comp_suf}"
                [ $? -ne 0 ] && shtool_exit $?
            fi
            #   finally get rid of the out-rotated logfile
            if [ ".$opt_t" = .yes ]; then
                echo "rm -f ${adir}/${file}.${n}${comp_suf}"
            fi
            rm -f ${adir}/${file}.${n}${comp_suf} || shtool_exit $?
        fi

        #   rotate already archived logfiles
        while [ $n -gt 0 ]; do
            m=$n
            n=`expr $n - 1`
            n=`echo dummy | awk "{ printf(\"%0${opt_p}d\", n); }" n=$n`
            if [ $n -eq 0 ] && [ ".$opt_d" = .yes ]; then
                #   special case: first rotation file under delayed compression situation
                if [ ! -f "${adir}/${file}.${n}" ]; then
                    continue
                fi

                #   compress file (delayed)
                if [ ".$opt_b" = .yes ]; then
                    if [ ".$opt_t" = .yes ]; then
                        echo "mv ${adir}/${file}.${n} ${adir}/${file}.${m}"
                    fi
                    mv ${adir}/${file}.${n} ${adir}/${file}.${m} || shtool_exit $?
                    if [ ".$opt_t" = .yes ]; then
                        echo "(${comp_prg} ${comp_lvl} <${adir}/${file}.${m} >${adir}/${file}.${m}${comp_suf}; rm -f ${adir}/${file}.${m}) &"
                    fi
                    ( ${comp_prg} ${comp_lvl} \
                          <${adir}/${file}.${m} \
                          >${adir}/${file}.${m}${comp_suf} || shtool_exit $?
                      rm -f ${adir}/${file}.${m} || shtool_exit $?
                    ) </dev/null >/dev/null 2>&1 &
                else
                    if [ ".$opt_t" = .yes ]; then
                        echo "${comp_prg} ${comp_lvl} <${adir}/${file}.${n} >${adir}/${file}.${m}${comp_suf}"
                    fi
                    ${comp_prg} ${comp_lvl} \
                        <${adir}/${file}.${n} \
                        >${adir}/${file}.${m}${comp_suf} || shtool_exit $?
                    if [ ".$opt_t" = .yes ]; then
                        echo "rm -f ${adir}/${file}.${n}"
                    fi
                    rm -f ${adir}/${file}.${n} || shtool_exit $?
                fi

                #   fix file attributes
                if [ ".$opt_o" != . ]; then
                    if [ ".$opt_t" = .yes ]; then
                        echo "chown $opt_o ${adir}/${file}.${m}${comp_suf}"
                    fi
                    chown $opt_o ${adir}/${file}.${m}${comp_suf} || shtool_exit $?
                fi
                if [ ".$opt_g" != . ]; then
                    if [ ".$opt_t" = .yes ]; then
                        echo "chgrp $opt_g ${adir}/${file}.${m}${comp_suf}"
                    fi
                    chgrp $opt_g ${adir}/${file}.${m}${comp_suf} || shtool_exit $?
                fi
                if [ ".$opt_m" != . ]; then
                    if [ ".$opt_t" = .yes ]; then
                        echo "chmod $opt_m ${adir}/${file}.${m}${comp_suf}"
                    fi
                    chmod $opt_m ${adir}/${file}.${m}${comp_suf} || shtool_exit $?
                fi
            else
                #   standard case: second and following rotation file
                if [ ! -f "${adir}/${file}.${n}${comp_suf}" ]; then
                    continue
                fi
                if [ ".$opt_t" = .yes ]; then
                    echo "mv ${adir}/${file}.${n}${comp_suf} ${adir}/${file}.${m}${comp_suf}"
                fi
                mv ${adir}/${file}.${n}${comp_suf} ${adir}/${file}.${m}${comp_suf} || shtool_exit $?
            fi
        done

        #   move away current logfile
        if [ ".$opt_c" = .yes ]; then
            #   approach: copy[+truncate]
            if [ ".$opt_t" = .yes ]; then
                echo "cp -p ${ldir}/${file} ${adir}/${file}.${n}"
            fi
            cp -p ${ldir}/${file} ${adir}/${file}.${n} || shtool_exit $?
            if [ ".$opt_r" = .no ]; then
                if [ ".$opt_t" = .yes ]; then
                    echo "cp /dev/null ${ldir}/${file}"
                fi
                cp /dev/null ${ldir}/${file} || shtool_exit $?
            fi
        else
            #   approach: move[+touch]
            if [ ".$opt_t" = .yes ]; then
                echo "mv ${ldir}/${file} ${adir}/${file}.${n}"
            fi
            mv ${ldir}/${file} ${adir}/${file}.${n} || shtool_exit $?
            if [ ".$opt_r" = .no ]; then
                if [ ".$opt_t" = .yes ]; then
                    echo "touch ${ldir}/${file}"
                fi
                touch ${ldir}/${file} || shtool_exit $?
                #   fix file attributes
                if [ ".$opt_o" != . ]; then
                    if [ ".$opt_t" = .yes ]; then
                        echo "chown $opt_o ${ldir}/${file}"
                    fi
                    chown $opt_o ${ldir}/${file} || shtool_exit $?
                fi
                if [ ".$opt_g" != . ]; then
                    if [ ".$opt_t" = .yes ]; then
                        echo "chgrp $opt_g ${ldir}/${file}"
                    fi
                    chgrp $opt_g ${ldir}/${file} || shtool_exit $?
                fi
                if [ ".$opt_m" != . ]; then
                    if [ ".$opt_t" = .yes ]; then
                        echo "chmod $opt_m ${ldir}/${file}"
                    fi
                    chmod $opt_m ${ldir}/${file} || shtool_exit $?
                fi
            fi
        fi

        #   regular compression step
        if [ ".$opt_z" != . ] && [ ".$opt_d" = .no ]; then
            #   compress file
            if [ ".$opt_b" = .yes ]; then
                if [ ".$opt_t" = .yes ]; then
                    echo "(${comp_prg} ${comp_lvl} <${adir}/${file}.${n} >${adir}/${file}.${n}${comp_suf}; rm -f ${adir}/${file}.${n}) &"
                fi
                ( ${comp_prg} ${comp_lvl} \
                      <${adir}/${file}.${n} \
                      >${adir}/${file}.${n}${comp_suf} || shtool_exit $?
                  rm -f ${adir}/${file}.${n} || shtool_exit $?
                ) </dev/null >/dev/null 2>&1 &
            else
                if [ ".$opt_t" = .yes ]; then
                    echo "${comp_prg} ${comp_lvl} <${adir}/${file}.${n} >${adir}/${file}.${n}${comp_suf}"
                fi
                ${comp_prg} ${comp_lvl} \
                    <${adir}/${file}.${n} \
                    >${adir}/${file}.${n}${comp_suf} || shtool_exit $?
                if [ ".$opt_t" = .yes ]; then
                    echo "rm -f ${opt_a}${file}.${n}"
                fi
                rm -f ${adir}/${file}.${n} || shtool_exit $?
            fi

            #   fix file attributes
            if [ ".$opt_o" != . ]; then
                if [ ".$opt_t" = .yes ]; then
                    echo "chown $opt_o ${adir}/${file}.${n}${comp_suf}"
                fi
                chown $opt_o ${adir}/${file}.${n}${comp_suf} || shtool_exit $?
            fi
            if [ ".$opt_g" != . ]; then
                if [ ".$opt_t" = .yes ]; then
                    echo "chgrp $opt_g ${adir}/${file}.${n}${comp_suf}"
                fi
                chgrp $opt_g ${adir}/${file}.${n}${comp_suf} || shtool_exit $?
            fi
            if [ ".$opt_m" != . ]; then
                if [ ".$opt_t" = .yes ]; then
                    echo "chmod $opt_m ${adir}/${file}.${n}${comp_suf}"
                fi
                chmod $opt_m ${adir}/${file}.${n}${comp_suf} || shtool_exit $?
            fi
        fi

        #   execute epilog
        if [ ".$opt_E" != . ]; then
            if [ ".$opt_t" = .yes ]; then
                echo "$opt_E"
            fi
            eval $opt_E
            [ $? -ne 0 ] && shtool_exit $?
        fi
    done

    shtool_exit 0
    ;;

tarball )
    ##
    ##  tarball -- Roll distribution tarballs
    ##  Copyright (c) 1999-2008 Ralf S. Engelschall <rse@engelschall.com>
    ##

    srcs="$*"

    #   check whether the test command supports the -x option
    if [ -x /bin/sh ] 2>/dev/null; then
        minusx="-x"
    else
        minusx="-r"
    fi

    #   find the tools
    paths="`echo $PATH |\
            sed -e 's%/*:%:%g' -e 's%/*$%%' \
                -e 's/^:/.:/' -e 's/::/:.:/g' -e 's/:$/:./' \
                -e 's/:/ /g'`"
    for spec in find:gfind,find tar:gtar,tar tardy:tardy,tarcust; do
        prg=`echo $spec | sed -e 's/:.*$//'`
        tools=`echo $spec | sed -e 's/^.*://'`
        eval "prg_${prg}=''"
        #   iterate over tools
        for tool in `echo $tools | sed -e 's/,/ /g'`; do
            #   iterate over paths
            for path in $paths; do
                if [ $minusx "$path/$tool" ] && [ ! -d "$path/$tool" ]; then
                    eval "prg_${prg}=\"$path/$tool\""
                    break
                fi
            done
            eval "val=\$prg_${prg}"
            if [ ".$val" != . ]; then
                break
            fi
        done
    done

    #   expand source paths
    exclude=''
    for pat in `echo $opt_e | sed 's/,/ /g'`; do
        exclude="$exclude | grep -v '$pat'"
    done
    if [ ".$opt_t" = .yes ]; then
        echo "cp /dev/null $tmpfile.lst" 1>&2
    fi
    cp /dev/null $tmpfile.lst
    for src in $srcs; do
        if [ -d $src ]; then
            if [ ".$opt_t" = .yes ]; then
                echo "(cd $src && $prg_find . -type f -depth -print) | sed -e 's:^\\.\$::' -e 's:^\\./::' | cat $exclude >>$tmpfile.lst" 1>&2
            fi
            (cd $src && $prg_find . -type f -depth -print) |\
            sed -e 's:^\.$::' -e 's:^\./::' | eval cat $exclude >>$tmpfile.lst
        else
            if [ ".$opt_t" = .yes ]; then
                echo "echo $src >>$tmpfile.lst" 1>&2
            fi
            echo $src >>$tmpfile.lst
        fi
    done
    sort <$tmpfile.lst >$tmpfile.lst.n
    mv $tmpfile.lst.n $tmpfile.lst
    if [ ".$opt_v" = .yes ]; then
        cat $tmpfile.lst | sed -e 's/^/  /' 1>&2
    fi

    #   determine tarball file and directory name
    if [ ".$opt_o" != . ]; then
        tarfile="$opt_o"
        if [ ".$opt_d" != . ]; then
            tarname="$opt_d"
        else
            tarname=`echo $tarfile | sed -e 's/\.tar.*$//' -e 's;.*/\([^/]*\)$;\1;'`
        fi
    else
        if [ ".$opt_d" != . ]; then
            tarname="$opt_d"
        elif [ -d "$from" ]; then
            tarname=`echo $from | sed -e 's;.*/\([^/]*\)$;\1;'`
        else
            tarname="out"
        fi
        tarfile="$tarname.tar"
    fi

    #   roll the tarball
    compress=''
    if [ ".$opt_c" != . ]; then
        compress="| $opt_c"
    fi
    if [ ".$prg_tardy" != . ]; then
        #   the elegant hackers way
        tardy_opt="--prefix=$tarname"
        tardy_opt="$tardy_opt --user_number=0 --group_number=0" # security!
        if [ ".$opt_u" != . ]; then
            tardy_opt="$tardy_opt --user_name=$opt_u"
        fi
        if [ ".$opt_g" != . ]; then
            tardy_opt="$tardy_opt --group_name=$opt_g"
        fi
        if [ ".$opt_t" = .yes ]; then
            echo "cat $tmpfile.lst | xargs $prg_tar cf - | $prg_tardy $tardy_opt | cat $compress >$tmpfile.out" 1>&2
        fi
        cat $tmpfile.lst |\
        xargs $prg_tar cf - |\
        $prg_tardy $tardy_opt |\
        eval cat $compress >$tmpfile.out
        if [ ".$opt_t" = .yes ]; then
            echo "cp $tmpfile.out $tarfile" 1>&2
        fi
        cp $tmpfile.out $tarfile
    else
        #  the portable standard way
        if [ ".$opt_t" = .yes ]; then
            echo "mkdir $tmpdir/$tarname" 1>&2
        fi
        mkdir $tmpdir/$tarname || shtool_exit 1
        if [ ".$opt_t" = .yes ]; then
            echo "cat $tmpfile.lst | xargs $prg_tar cf - | (cd $tmpdir/$tarname && $prg_tar xf -)" 1>&2
        fi
        cat $tmpfile.lst |\
        xargs $prg_tar cf - |\
        (cd $tmpdir/$tarname && $prg_tar xf -)
        if [ ".$opt_u" != . ]; then
            if [ ".$opt_t" = .yes ]; then
                echo "chown -R $opt_u $tmpdir/$tarname >/dev/null 2>&1" 2>&1
            fi
            chown -R $opt_u $tmpdir/$tarname >/dev/null 2>&1 ||\
            echo "$msgprefix:Warning: cannot set user name \`$opt_u' (would require root privileges)"
        fi
        if [ ".$opt_g" != . ]; then
            if [ ".$opt_t" = .yes ]; then
                echo "chgrp -R $opt_g $tmpdir/$tarname >/dev/null 2>&1" 2>&1
            fi
            chgrp -R $opt_g $tmpdir/$tarname >/dev/null 2>&1 ||\
            echo "$msgprefix:Warning: cannot set group name \`$opt_g' (would require root privileges)"
        fi
        if [ ".$opt_t" = .yes ]; then
            echo "(cd $tmpdir && $prg_find $tarname -type f -depth -print | sort | xargs $prg_tar cf -) | cat $compress >$tmpfile.out" 1>&2
        fi
        (cd $tmpdir && $prg_find $tarname -type f -depth -print | sort | xargs $prg_tar cf -) |\
        eval cat $compress >$tmpfile.out
        if [ ".$opt_t" = .yes ]; then
            echo "cp $tmpfile.out $tarfile" 1>&2
        fi
        cp $tmpfile.out $tarfile
        if [ ".$opt_t" = .yes ]; then
            echo "rm -rf $tmpdir/$tarname" 1>&2
        fi
        rm -rf $tmpdir/$tarname
    fi

    #   cleanup
    if [ ".$opt_t" = .yes ]; then
        echo "rm -f $tmpfile.lst $tmpfile.out" 1>&2
    fi
    rm -f $tmpfile.lst $tmpfile.out

    shtool_exit 0
    ;;

subst )
    ##
    ##  subst -- Apply sed(1) substitution operations
    ##  Copyright (c) 2001-2008 Ralf S. Engelschall <rse@engelschall.com>
    ##

    #   remember optional list of file(s)
    files="$*"
    files_num="$#"

    #   parameter consistency check
    if [ $# -eq 0 ] && [ ".$opt_b" != . ]; then
        echo "$msgprefix:Error: option -b cannot be applied to stdin" 1>&2
        shtool_exit 1
    fi
    if [ $# -eq 0 ] && [ ".$opt_s" = .yes ]; then
        echo "$msgprefix:Error: option -s cannot be applied to stdin" 1>&2
        shtool_exit 1
    fi

    #   build underlying sed(1) command
    sedcmd='sed'
    if [ ".$opt_e" != . ]; then
        OIFS="$IFS"; IFS="$ASC_NL"; set -- $opt_e; IFS="$OIFS"
        for e
        do
            sedcmd="$sedcmd -e '$e'"
        done
    elif [ ".$opt_f" != . ]; then
        if [ ! -f $opt_f ]; then
            echo "$msgprefix:Error: command file \`$opt_f' not found or not a regular file" 1>&2
            shtool_exit 1
        fi
        sedcmd="$sedcmd -f '$opt_f'"
    else
        echo "$msgprefix:Error: either -e option(s) or -f option required" 1>&2
        shtool_exit 1
    fi

    #   determine extension for original file
    orig=".orig"
    if [ ".$opt_b" != . ]; then
        orig="$opt_b"
    fi

    #   apply sed(1) operation(s)
    if [ ".$files" != . ]; then
        #   apply operation(s) to files
        substdone=no
        for file in $files; do
            test ".$file" = . && continue
            if [ ! -f $file ]; then
                echo "$msgprefix:Warning: file \`$file' not found or not a regular file" 1>&2
                continue
            fi

            #   handle interactive mode
            if [ ".$opt_i" = .yes ]; then
                eval "$sedcmd <$file >$file.new"
                skip=no
                if cmp $file $file.new >/dev/null 2>&1; then
                    rm -f $file.new
                    skip=yes
                else
                    (diff -U1 $file $file.new >$tmpfile) 2>/dev/null
                    if [ ".`cat $tmpfile`" = . ]; then
                        (diff -C1 $file $file.new >$tmpfile) 2>/dev/null
                        if [ ".`cat $tmpfile`" = . ]; then
                            echo "$msgprefix:Warning: unable to show difference for file \`$file'" 1>&2
                            cp /dev/null $tmpfile
                        fi
                    fi
                    rm -f $file.new
                    cat $tmpfile
                    echo dummy | awk '{ printf("%s", TEXT); }' TEXT=">>> Apply [Y/n]: "
                    read input
                    if [ ".$input" != .Y ] &&\
                       [ ".$input" != .y ] &&\
                       [ ".$input" != . ]; then
                       skip=yes
                    fi
                fi
                if [ ".$skip" = .yes ]; then
                    if [ ".$opt_v" = .yes ]; then
                        echo "file \`$file' -- skipped" 1>&2
                    fi
                    continue
                fi
            fi

            #   apply sed(1) operation(s)
            if [ ".$opt_v" = .yes ]; then
                echo "patching \`$file'" 1>&2
            fi
            if [ ".$opt_t" = .yes ]; then
                echo "\$ cp -p $file $file$orig"
                echo "\$ chmod u+w $file"
                echo "\$ $sedcmd <$file$orig >$file"
            fi
            if [ ".$opt_n" = .no ]; then
                cp -p $file $file$orig
                chmod u+w $file >/dev/null 2>&1 || true
                eval "$sedcmd <$file$orig >$file"
            fi

            #   optionally fix timestamp
            if [ ".$opt_s" = .yes ]; then
                if [ ".$opt_t" = .yes ]; then
                    echo "\$ touch -r $file$orig $file"
                fi
                if [ ".$opt_n" = .no ]; then
                    touch -r $file$orig $file
                fi
            fi

            #   optionally check whether any content change actually occurred
            if [ ".$opt_q" = .no ]; then
                if cmp $file$orig $file >/dev/null 2>&1; then
                    if [ ".$opt_w" = .yes ]; then
                        echo "$msgprefix:Warning: substitution resulted in no content change on file \"$file\"" 1>&2
                    fi
                else
                    substdone=yes
                fi
            fi

            #   optionally remove preserved original file
            if [ ".$opt_b" = . ]; then
                if [ ".$opt_t" = .yes ]; then
                    echo "\$ rm -f $file$orig"
                fi
                if [ ".$opt_n" = .no ]; then
                    rm -f $file$orig
                fi
            fi
        done
        if [ ".$opt_q" = .no ] && [ ".$opt_w" = .no ]; then
            if [ ".$substdone" = .no ]; then
                if [ ".$files_num" = .1 ]; then
                    echo "$msgprefix:Warning: substitution resulted in no content change on file \"$file\"" 1>&2
                else
                    echo "$msgprefix:Warning: substitution resulted in no content change on any file" 1>&2
                fi
            fi
        fi
    else
        #   apply operation(s) to stdin/stdout
        if [ ".$opt_v" = .yes ]; then
            echo "patching <stdin>" 1>&2
        fi
        if [ ".$opt_t" = .yes ]; then
            echo "\$ $sedcmd"
        fi
        if [ ".$opt_n" = .no ]; then
            eval "$sedcmd"
        fi
    fi

    shtool_exit 0
    ;;

platform )
    ##
    ##  platform -- Platform Identification Utility
    ##  Copyright (c) 2003-2008 Ralf S. Engelschall <rse@engelschall.com>
    ##

    #   option post-processing
    if [ ".$opt_t" != . ]; then
        case "$opt_t" in
            binary )
                #   binary package id (OpenPKG RPM)
                opt_F="%<ap>-%<sp>"
                opt_L=yes
                opt_S=""
                opt_C="+"
                ;;
            build )
                #   build time checking (OpenPKG RPM)
                opt_F="%<at>-%<st>"
                opt_L=yes
                opt_S=""
                opt_C="+"
                ;;
            gnu )
                #   GNU config.guess style <arch>-<vendor>-<os><osversion>
                opt_F="%<at>-unknown-%<st>"
                opt_L=yes
                opt_S=""
                opt_C="+"
                ;;
            web )
                #   non-whitespace HTTP Server-header id
                opt_F="%<sp>-%<ap>"
                opt_S="/"
                opt_C="+"
                ;;
            summary)
                #   human readable verbose summary information
                opt_F="Class:      %[sc] (%[ac])\\nProduct:    %[sp] (%[ap])\\nTechnology: %[st] (%[at])"
                opt_S=" "
                opt_C="/"
                ;;
            all-in-one )
                #   full-table all-in-one information
                opt_F=""
                opt_F="${opt_F}concise architecture class:      %<ac>\\n"
                opt_F="${opt_F}regular architecture class:      %{ac}\\n"
                opt_F="${opt_F}verbose architecture class:      %[ac]\\n"
                opt_F="${opt_F}concise architecture product:    %<ap>\\n"
                opt_F="${opt_F}regular architecture product:    %{ap}\\n"
                opt_F="${opt_F}verbose architecture product:    %[ap]\\n"
                opt_F="${opt_F}concise architecture technology: %<at>\\n"
                opt_F="${opt_F}regular architecture technology: %{at}\\n"
                opt_F="${opt_F}verbose architecture technology: %[at]\\n"
                opt_F="${opt_F}concise system class:            %<sc>\\n"
                opt_F="${opt_F}regular system class:            %{sc}\\n"
                opt_F="${opt_F}verbose system class:            %[sc]\\n"
                opt_F="${opt_F}concise system product:          %<sp>\\n"
                opt_F="${opt_F}regular system product:          %{sp}\\n"
                opt_F="${opt_F}verbose system product:          %[sp]\\n"
                opt_F="${opt_F}concise system technology:       %<st>\\n"
                opt_F="${opt_F}regular system technology:       %{st}\\n"
                opt_F="${opt_F}verbose system technology:       %[st]"
                ;;
            * )
                echo "$msgprefix:Error: invalid type \`$opt_t'" 1>&2
                exit 1
                ;;
        esac
    fi

    #   assemble initial platform information
    UNAME_MACHINE=`(uname -m) 2>/dev/null` ||\
    UNAME_MACHINE=`(uname -p) 2>/dev/null` ||\
    UNAME_MACHINE='unknown'
    UNAME_SYSTEM=`(uname -s) 2>/dev/null`  ||\
    UNAME_SYSTEM='unknown'
    UNAME_RELEASE=`(uname -r) 2>/dev/null` ||\
    UNAME_RELEASE=`(uname -v) 2>/dev/null` ||\
    UNAME_RELEASE='unknown'

    UNAME="${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}"

    AC=""; AP=""; AT=""
    SC=""; SP=""; ST=""

    #    dispatch into platform specific sections
    case "${UNAME}" in

        #   FreeBSD
        *:FreeBSD:* )
            #   determine architecture
            AC="${UNAME_MACHINE}"
            case "${AC}" in
                i386 ) AC="iX86" ;;
            esac
            AP="${AC}"
            AT="${AP}"
            if [ ".${AT}" = ".iX86" ]; then
                case "`(/sbin/sysctl -n hw.model) 2>&1`" in
                    *"Xeon"* | *"Pentium Pro"* | *"Cyrix 6x86MX"* | *"Pentium II"* | *"Pentium III"* | *"Pentium 4"* | *"Celeron"* ) AT="i686" ;;
                    *"Pentium"* ) AT="i586" ;; *"i486[SD]X"* | *"Cyrix 486"* | *"Cyrix [56]x86"* | *"Blue Lightning" | *"Cyrix 486S/DX" ) AT="i486" ;;
                    *"i386[SD]X"* | *"NexGen 586"* ) AT="i386" ;;
                esac
            fi
            #   determine system
            r=`echo "${UNAME_RELEASE}" |\
               sed -e 's;[()];;' -e 's/\(-.*\)$/[\1]/'`
            ST="FreeBSD ${r}"
            SP="${ST}"
            case "${r}" in
                1.* ) SC="4.3BSD" ;;
                *   ) SC="4.4BSD" ;;
            esac
            ;;

        #   NetBSD
        *:NetBSD:* )
            #   determine architecture
            AT="${UNAME_MACHINE}"
            AP="${AT}"
            case "${AP}" in
                i[3-6]86 ) AP="iX86" ;;
            esac
            AC="${AP}"
            #   determine system
            r=`echo "${UNAME_RELEASE}" | sed -e 's/\([-_].*\)$/[\1]/'`
            ST="NetBSD ${r}"
            SP="${ST}"
            case "${r}" in
                0.* ) SC="4.3BSD" ;;
                *   ) SC="4.4BSD" ;;
            esac
            ;;

        #   OpenBSD
        *:OpenBSD:* )
            #   determine architecture
            AT="${UNAME_MACHINE}"
            AP="${AT}"
            case "${AP}" in
                i[3-6]86 ) AP="iX86" ;;
            esac
            AC="${AP}"
            #   determine system
            r=`echo "${UNAME_RELEASE}" | sed -e 's/\([-_].*\)$/[\1]/'`
            ST="OpenBSD ${r}"
            SP="${ST}"
            SC="4.4BSD"
            ;;

        #   DragonFly BSD
        *:DragonFly:* )
            #   determine architecture
            AT="${UNAME_MACHINE}"
            AP="${AT}"
            case "${AP}" in
                i[3-6]86 ) AP="iX86" ;;
            esac
            AC="${AP}"
            #   determine system
            r=`echo "${UNAME_RELEASE}" | sed -e 's/\([-_].*\)$/[\1]/'`
            ST="DragonFly ${r}"
            SP="${ST}"
            SC="4.4BSD"
            ;;

        #   GNU/Linux
        *:Linux:* )
            #   determine architecture
            AT="${UNAME_MACHINE}"
            case "${AT}" in
               ia64     ) AT="IA64"   ;;
               x86_64   ) AT='AMD64'  ;;
               parisc   ) AT="HPPA32" ;;
               parisc64 ) AT="HPPA64" ;;
            esac
            AP="${AT}"
            case "${AP}" in
               i[3-6]86 ) AP='iX86' ;;
            esac
            AC="${AP}"
            #   determine system
            v_kern=`echo "${UNAME_RELEASE}" |\
                sed -e 's/^\([0-9][0-9]*\.[0-9][0-9]*\).*/\1/'`
            v_libc=`(strings /lib/libc.so.* | grep '^GLIBC_' | sed -e 's/^GLIBC_//' |\
                env -i sort -n | sed -n -e '$p' | sed -e 's/^\([0-9][0-9]*\.[0-9][0-9]*\).*/\1/') 2>/dev/null`
            ST="GNU/<Linux >${v_libc}/<${v_kern}>"
            if [ -f /etc/lsb-release ]; then
                eval `( . /etc/lsb-release
                    echo "SC=\"LSB${LSB_VERSION}\""
                    if [ ".${DISTRIB_ID}" != . -a ".${DISTRIB_RELEASE}" != . ]; then
                        echo "SP=\"${DISTRIB_ID} ${DISTRIB_RELEASE}\""
                    fi
                ) 2>/dev/null`
            fi
            if [ ".$SP" = . ]; then
                for tagfile in x \
                    `cd /etc && \
                    /bin/ls *[_-]release *[_-]version 2>/dev/null | env -i sort | \
                    sed -e '/^redhat-release$/d' -e '/^lsb-release$/d'; \
                    echo redhat-release lsb-release`
                do
                    [ ".${tagfile}" = .x ] && continue
                    [ ! -f "/etc/${tagfile}" ] && continue
                    n=`echo ${tagfile} | sed -e 's/[_-]release$//' -e 's/[_-]version$//'`
                    v=`(grep VERSION /etc/${tagfile}; cat /etc/${tagfile}) | grep '[0-9]' | sed -e 'q' |\
                       sed -e 's/^/#/' \
                           -e 's/^#[^0-9]*\([0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\).*$/\1/' \
                           -e 's/^#[^0-9]*\([0-9][0-9]*\.[0-9][0-9]*\).*$/\1/' \
                           -e 's/^#[^0-9]*\([0-9][0-9]*\).*$/\1/' \
                           -e 's/^#.*$//'`
                    case "`util_lower ${n}`" in
                        redhat )
                            if [ ".`egrep '(Red Hat Enterprise Linux|CentOS)' /etc/${tagfile}`" != . ]; then
                                n="<R>ed <H>at <E>nterprise <L>inux"
                            else
                                n="<R>ed <H>at <L>inux"
                            fi
                            ;;
                        debian             ) n="Debian[ GNU/Linux]"        ;;
                        ubuntu             ) n="Ubuntu[ GNU/Linux]"        ;;
                        fedora             ) n="<Fedora> Core[ GNU/Linux]" ;;
                        suse               ) n="[Novell ]SUSE[ Linux]"     ;;
                        mandrake*|mandriva ) n="Mandriva[ Linux]"          ;;
                        gentoo             ) n="Gentoo[ GNU/Linux]"        ;;
                        slackware          ) n="Slackware[ Linux]"         ;;
                        turbolinux         ) n="TurboLinux"                ;;
                        unitedlinux        ) n="UnitedLinux"               ;;
                        *                  ) n="${n}[ GNU/Linux]"          ;;
                    esac
                    case "$n" in
                        *"<"*">"* ) SP="$n <$v>" ;;
                        *         ) SP="$n $v"   ;;
                    esac
                    break
                done
            fi
            [ ".$SP" = . ] && SP="${ST}"
            [ ".$SC" = . ] && SC="LSB"
            ;;

        #   Sun Solaris
        *:SunOS:* )
            #   determine architecture
            AT="${UNAME_MACHINE}"
            case "${AT}" in
                i86pc )
                    AT="iX86"
                    case "`(/bin/isainfo -k) 2>&1`" in
                        amd64 ) AT="AMD64" ;;
                    esac
                    ;;
            esac
            AP="${AT}"
            case "${AP}" in
                sun4[cdm] ) AP="SPARC32" ;;
                sun4[uv]  ) AP="SPARC64" ;;
                sun4*     ) AP="SPARC"   ;;
            esac
            AC="${AP}"
            case "${AC}" in
                SPARC* ) AC="SPARC" ;;
            esac
            #   determine system
            ST="[Sun ]SunOS ${UNAME_RELEASE}"
            v=`echo "${UNAME_RELEASE}" |\
               sed -e 's;^4\.;1.;' \
                   -e 's;^5\.\([0-6]\)[^0-9]*$;2.\1;' \
                   -e 's;^5\.\([0-9][0-9]*\).*;\1;'`
            SP="[Sun ]Solaris $v"
            case "${UNAME_RELEASE}" in
                4.* ) SC="4.3BSD" ;;
                5.* ) SC="SVR4"   ;;
            esac
            ;;

        #   SCO UnixWare
        *:UnixWare:* )
            #   determine architecture
            AT="${UNAME_MACHINE}"
            case "${AT}" in
                i[3-6]86 | ix86at ) AT="iX86" ;;
            esac
            AP="${AT}"
            #   determine system
            v=`/sbin/uname -v`
            ST="[SCO ]UnixWare ${v}"
            SP="${ST}"
            SC="SVR${UNAME_RELEASE}"
            ;;

        #   QNX
        *:QNX:* )
            #   determine architecture
            AT="${UNAME_MACHINE}"
            case "${AT}" in
                x86pc ) AT="iX86" ;;
            esac
            AP="${AT}"
            #   determine system
            v="${UNAME_RELEASE}"
            ST="QNX[ Neutrino RTOS] ${v}"
            v=`echo "${v}" | sed -e 's;^\([0-9][0-9]*\.[0-9][0-9]*\).*$;\1;'`
            SP="QNX[ Neutrino RTOS] ${v}"
            SC="QNX"
            ;;

        #   SGI IRIX
        *:IRIX*:* )
            #   determine architecture
            AT="${UNAME_MACHINE}"
            AP="${AT}"
            case "${AP}:${UNAME_SYSTEM}" in
                IP*:IRIX64 ) AP="MIPS64" ;;
                IP*:*      ) AP="MIPS"   ;;
            esac
            AC="${AP}"
            #   determine system
            v=`(/bin/uname -R || /bin/uname -r) 2>/dev/null | sed -e 's;[0-9.]* ;;'`
            ST="[SGI ]IRIX ${v}"
            v="${UNAME_RELEASE}"
            SP="[SGI ]IRIX ${v}"
            SC="4.2BSD/SVR3"
            ;;

        #   HP HP-UX
        *:HP-UX:* )
            #   determine architecture
            AT="${UNAME_MACHINE}"
            case "${AT}" in
                ia64 ) AT="IA64" ;;
                9000/[34]?? ) AT=M68K ;;
                9000/[678][0-9][0-9])
                    sc_cpu_version=`/usr/bin/getconf SC_CPU_VERSION 2>/dev/null`
                    sc_kernel_bits=`/usr/bin/getconf SC_KERNEL_BITS 2>/dev/null`
                    case "${sc_cpu_version}" in
                        523 ) AT="HPPA1.0" ;;
                        528 ) AT="HPPA1.1" ;;
                        532 ) AT="HPPA2.0"
                            case "${sc_kernel_bits}" in
                                32 ) AT="${AT}n" ;;
                                64 ) AT="${AT}w" ;;
                            esac
                            ;;
                    esac
                    ;;
            esac
            AP="${AT}"
            case "${AP}" in
                HPPA* ) AP="HPPA" ;;
            esac
            AC="${AP}"
            #   determine system
            v=`echo "${UNAME_RELEASE}" | sed -e 's;^[^0-9]*;;'`
            ST="[HP ]<HP>-<UX ${v}>"
            SP="${ST}"
            case "${v}" in
                10.*   ) SC="SVR4.2" ;;
                [7-9]* ) SC="SVR4"   ;;
            esac
            ;;

        #   HP Tru64 (OSF1)
        *:OSF1:* )
            #   determine architecture
            AP="${UNAME_MACHINE}"
            case "${AP}" in
                alpha ) AP="Alpha" ;;
            esac
            alpha_type=`(/usr/sbin/psrinfo -v) 2>/dev/null |\
                sed -n -e 's/^.*The alpha \([^ ][^ ]*\).*processor.*$/\1/p' | sed -e 'q'`
            AT="${AP}${alpha_type}"
            AC="${AP}"
            #   determine system
            v=`echo "${UNAME_RELEASE}" | sed -e 's;^[VTX];;'`
            ST="[HP ]Tru64 ${v}"
            SP="${ST}"
            SC="OSF1"
            ;;

        #   IBM AIX
        *:AIX:* )
            #   determine architecture
            cpu_arch=RS6000
            if [ -x /usr/sbin/lsdev -a -x /usr/sbin/lsattr ]; then
                cpu_id=`/usr/sbin/lsdev -C -c processor -S available | sed 1q | awk '{ print $1 }'`
                if [ ".`/usr/sbin/lsattr -El ${cpu_id} | grep -i powerpc`" != . ]; then
                    cpu_arch=PPC
                fi
            elif [ -d /QOpenSys ]; then
                #   IBM i5/OS (aka OS/400) with PASE (Portable Application Solutions Environment)
                cpu_arch=PPC
            fi
            if [ -x /usr/bin/oslevel ]; then
                os_level=`/usr/bin/oslevel`
            else
                os_level="`uname -v`.`uname -r`"
            fi
            os_level=`echo "${os_level}" |\
                      sed -e 's;^\([0-9][0-9]*\.[0-9][0-9]*\)\(\.[0-9][0-9]*\)\(.*\)$;<\1>\2[\3];' \
                          -e 's;^\([0-9][0-9]*\.[0-9][0-9]*\)\(.*\)$;<\1>\2;'`
            AT="${cpu_arch}"
            AP="${AT}"
            AC="${AP}"
            #   determine system
            ST="[IBM ]<AIX >${os_level}"
            SP="${ST}"
            case "${os_level}" in
                [12]* ) SC="SVR2" ;;
                *     ) SC="SVR4" ;;
            esac
            ;;

        #   Apple Mac OS X (Darwin)
        *:Darwin:* )
            #   determine architecture
            AT="`uname -p`"
            case "${AT}" in
                powerpc ) AT="PPC" ;;
            esac
            AP="${AT}"
            case "${AP}" in
                i?86 ) AP="iX86" ;;
            esac
            AC="${AP}"
            #   determine system
            unset v1; unset v2; unset v3
            eval `echo "${UNAME_RELEASE}" |\
                  sed -e 's/^/#/' \
                      -e 's/^#\([0-9][0-9]*\)\.\([0-9][0-9]*\)\.\([0-9][0-9]*\).*$/v1="\1"; v2="\2"; v3="\3"/' \
                      -e 's/^#\([0-9][0-9]*\)\.\([0-9][0-9]*\).*$/v1="\1"; v2="\2"/' \
                      -e 's/^#\([0-9][0-9]*\).*$/v1="\1"/' \
                      -e 's/^#.*$/v1="0"/'`
            ST="[Apple ]<${UNAME_SYSTEM} ${v1}>${v2+.$v2}${v3+[.$v3]}"
            SP="$ST"
            v="`(sw_vers) 2>/dev/null | grep 'ProductVersion:' | sed -e 's/^ProductVersion:[^0-9]*\([0-9][0-9.]*\).*$/\1/'`"
            if [ ".$v" = . ]; then
                for name in System Server; do
                    if [ -f /System/Library/CoreServices/${name}Version.plist ]; then
                        v=`(defaults read "/System/Library/CoreServices/${name}Version" "ProductVersion") 2>/dev/null`
                        [ ".$v" != . ] && break
                    fi
                done
            fi
            if [ ".$v" != . ]; then
                unset v1; unset v2; unset v3
                eval `echo "${v}" |\
                      sed -e 's/^/#/' \
                          -e 's/^#\([0-9][0-9]*\)\.\([0-9][0-9]*\)\.\([0-9][0-9]*\).*$/v1="\1"; v2="\2"; v3="\3"/' \
                          -e 's/^#\([0-9][0-9]*\)\.\([0-9][0-9]*\).*$/v1="\1"; v2="\2"/' \
                          -e 's/^#\([0-9][0-9]*\).*$/v1="\1"/' \
                          -e 's/^#.*$/v1="0"/'`
                SP="[Apple ]Mac OS X ${v1}${v2+.$v2}${v3+[.$v3]}"
            fi
            SC="4.4BSD/Mach3.0"
            ;;

        #   Windows/Cygwin
        *:CYGWIN*:* )
            #   determine architecture
            AT="`uname -m`"
            AP="${AT}"
            case "${AP}" in
                i?86 ) AP="iX86" ;;
            esac
            AC="${AP}"
            #   determine system
            unset v1; unset v2; unset v3
            eval `echo "${UNAME_RELEASE}" |\
                  sed -e 's/^/#/' \
                      -e 's/^#\([0-9][0-9]*\)\.\([0-9][0-9]*\)\.\([0-9][0-9]*\).*$/v1="\1"; v2="\2"; v3="\3"/' \
                      -e 's/^#\([0-9][0-9]*\)\.\([0-9][0-9]*\).*$/v1="\1"; v2="\2"/' \
                      -e 's/^#\([0-9][0-9]*\).*$/v1="\1"/' \
                      -e 's/^#.*$/v1="0"/'`
            ST="Cygwin ${v1}${v2+.$v2}${v3+[.$v3]}"
            SP="$ST"
            SC="Windows"
            v=`echo "${UNAME_SYSTEM}" | sed -e 's/^CYGWIN_NT-//' |\
               sed -e 's/^/#/' -e 's/^#\([0-9][0-9]*\.[0-9][0-9]*\).*$/\1/' -e 's/^#.*$//'`
            case "$v" in
                4.0 ) SC="$SC[ NT]"    ;;
                5.0 ) SC="$SC[ 2000]"  ;;
                5.1 ) SC="$SC[ XP]"    ;;
                6.0 ) SC="$SC[ Vista]" ;;
            esac
            ;;

        #   TODO ...ADD YOUR NEW PLATFORM CHECK HERE... TODO
        # *:XXX:* )
        #   ...
        #   ;;

        #   ...A STILL UNKNOWN PLATFORM...
        * )
            AT=`echo "${UNAME_MACHINE}" | sed -e "s; ;${opt_C};g"`
            AP="${AT}"
            AC="${AP}"
            v=`echo "${UNAME_RELEASE}" |\
               sed -e 's/^/#/' \
                   -e 's/^#[^0-9]*\([0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\).*$/\1/' \
                   -e 's/^#[^0-9]*\([0-9][0-9]*\.[0-9][0-9]*\).*$/\1/' \
                   -e 's/^#[^0-9]*\([0-9][0-9]*\).*$/\1/' \
                   -e 's/^#.*$/?/'`
            ST="${UNAME_SYSTEM} ${v}"
            SP="${ST}"
            SC="${SP}"
            ;;

    esac

    #   provide fallback values
    [ ".$AT" = . ] && AT="${AP:-${AC}}"
    [ ".$AP" = . ] && AP="${AT:-${AC}}"
    [ ".$AC" = . ] && AC="${AP:-${AT}}"
    [ ".$ST" = . ] && ST="${SP:-${SC}}"
    [ ".$SP" = . ] && SP="${ST:-${SC}}"
    [ ".$SC" = . ] && SC="${SP:-${ST}}"

    #   support explicit enforced verbose/concise output
    if [ ".$opt_v" = .yes ]; then
        opt_F=`echo ":$opt_F" | sed -e 's/^://' -e 's/%\([as][cpt]\)/%[\1]/g'`
    elif [ ".$opt_c" = .yes ]; then
        opt_F=`echo ":$opt_F" | sed -e 's/^://' -e 's/%\([as][cpt]\)/%<\1>/g'`
    fi

    #   provide verbose and concise variants
    AC_V=""; AC_N=""; AC_C=""
    AP_V=""; AP_N=""; AP_C=""
    AT_V=""; AT_N=""; AT_C=""
    SC_V=""; SC_N=""; SC_C=""
    SP_V=""; SP_N=""; SP_C=""
    ST_V=""; ST_N=""; ST_C=""
    for var_lc in at ap ac st sp sc; do
        case "$opt_F" in
            *"%[${val_lc}]"* | *"%{${val_lc}}"* | *"%${val_lc}"* | *"%<${val_lc}>"* )
            var_uc=`util_upper "$var_lc"`
            eval "val=\"\$${var_uc}\""
            val_V=""; val_N=""; val_C=""
            case "$opt_F" in
                *"%[${var_lc}]"* )
                    val_V=`echo ":$val" | \
                           sed -e 's/^://' \
                               -e 's;\[\([^]]*\)\];\1;g' \
                               -e 's;<\([^>]*\)>;\1;g' \
                               -e "s; ;;g" \
                               -e "s;/;%%;g" \
                               -e "s;;${opt_S};g" \
                               -e "s;%%;${opt_C};g"`
                    eval "${var_uc}_V=\"\${val_V}\""
                    ;;
            esac
            case "$opt_F" in
                *"%{${var_lc}}"* | *"%${var_lc}"* )
                    val_N=`echo ":$val" | \
                           sed -e 's/^://' \
                               -e 's;\[\([^]]*\)\];;g' \
                               -e 's;<\([^>]*\)>;\1;g' \
                               -e "s; ;;g" \
                               -e "s;/;%%;g" \
                               -e "s;;${opt_S};g" \
                               -e "s;%%;${opt_C};g"`
                    eval "${var_uc}_N=\"\${val_N}\""
                    ;;
            esac
            case "$opt_F" in
                *"%<${var_lc}>"* )
                    val_C=`echo ":$val" | \
                           sed -e 's/^://' \
                               -e 's;\[\([^]]*\)\];;g' \
                               -e 's;[^<]*<\([^>]*\)>[^<]*;\1;g' \
                               -e "s; ;;g" \
                               -e "s;/;%%;g" \
                               -e "s;;${opt_S};g" \
                               -e "s;%%;${opt_C};g"`
                    eval "${var_uc}_C=\"\${val_C}\""
                    ;;
            esac
            ;;
        esac
    done

    #   create output string
    output=`echo ":$opt_F" |\
            sed -e "s/^://" \
                -e "s;%\\[ac\\];${AC_V};g" \
                -e "s;%{ac};${AC_N};g" \
                -e "s;%ac;${AC_N};g" \
                -e "s;%<ac>;${AC_C};g" \
                -e "s;%\\[ap\\];${AP_V};g" \
                -e "s;%{ap};${AP_N};g" \
                -e "s;%ap;${AP_N};g" \
                -e "s;%<ap>;${AP_C};g" \
                -e "s;%\\[at\\];${AT_V};g" \
                -e "s;%{at};${AT_N};g" \
                -e "s;%at;${AT_N};g" \
                -e "s;%<at>;${AT_C};g" \
                -e "s;%\\[sc\\];${SC_V};g" \
                -e "s;%{sc};${SC_N};g" \
                -e "s;%sc;${SC_N};g" \
                -e "s;%<sc>;${SC_C};g" \
                -e "s;%\\[sp\\];${SP_V};g" \
                -e "s;%{sp};${SP_N};g" \
                -e "s;%sp;${SP_N};g" \
                -e "s;%<sp>;${SP_C};g" \
                -e "s;%\\[st\\];${ST_V};g" \
                -e "s;%{st};${ST_N};g" \
                -e "s;%st;${ST_N};g" \
                -e "s;%<st>;${ST_C};g" \
                -e 's/\\\\n/^/g' |\
             tr '^' '\012'`

    #   support lower/upper-case mapping
    if [ ".$opt_L" = .yes ]; then
        output=`util_lower "$output"`
    elif [ ".$opt_U" = .yes ]; then
        output=`util_upper "$output"`
    fi

    #   display output string
    if [ ".$opt_n" = .yes ]; then
        echo . | awk '{ printf("%s", output); }' output="$output"
    else
        echo "$output"
    fi

    shtool_exit 0
    ;;

arx )
    ##
    ##  arx -- Extended archive command
    ##  Copyright (c) 1999-2008 Ralf S. Engelschall <rse@engelschall.com>
    ##

    ar_prg="$opt_C"
    ar_cmd="$1"; shift
    archive="$1"; shift
    files="$*"

    #   walk through the file list and expand archives members
    ar_tmpdir=`echo $archive | sed -e 's;[^/]*$;.arx;'`
    nfiles=''
    if [ ".$files" != . ]; then
        for file in $files; do
            if [ ! -f $file ]; then
                echo "$msgprefix:Error: input file not found: $file" 1>&2
                shtool_exit 1
            fi
            case $file in
                *.a )
                    if [ ! -d $ar_tmpdir ]; then
                        if [ ".$opt_t" = .yes ]; then
                            echo "mkdir $ar_tmpdir" 1>&2
                        fi
                        mkdir $ar_tmpdir
                    fi
                    case $ar_tmpdir in
                         .arx )
                             from="../$file"
                             ;;
                         * )
                             dir=`echo $file | sed -e 's;[^/]*$;;' -e 's;\(.\)/$;\1;' -e 's;^$;.;'`
                             base=`echo $file | sed -e 's;.*/\([^/]*\)$;\1;'`
                             from="`cd $dir; pwd`/$base"
                             ;;
                    esac
                    if [ ".$opt_t" = .yes ]; then
                        echo "(cd $ar_tmpdir && $ar_prg x $from)" 1>&2
                    fi
                    (cd $ar_tmpdir && eval $ar_prg x $from)
                    if [ $? -ne 0 ]; then
                        echo "$msgprefix:Error: member extraction failed for archive: $file" 1>&2
                        shtool_exit 1
                    fi
                    for member in - `eval $ar_prg t $file | sed -e '/_\.SYMDEF/d'`; do
                        [ ".$member" = .- ] && continue
                        nfiles="$nfiles $ar_tmpdir/$member"
                    done
                    ;;
                * )
                    nfiles="$nfiles $file"
                    ;;
            esac
        done
    fi

    #   run the final archive command
    if [ ".$opt_t" = .yes ]; then
        echo "$ar_prg $ar_cmd $archive $nfiles" 1>&2
    fi
    eval $ar_prg $ar_cmd $archive $nfiles
    if [ $? -ne 0 ]; then
        echo "$msgprefix:Error: archive command failed" 1>&2
        shtool_exit $?
    fi

    #   cleanup and die gracefully
    if [ -d $ar_tmpdir ]; then
        if [ ".$opt_t" = .yes ]; then
            echo "rm -rf $ar_tmpdir" 1>&2
        fi
        rm -rf $ar_tmpdir
    fi

    shtool_exit 0
    ;;

slo )
    ##
    ##  slo -- Separate linker options by library class
    ##  Copyright (c) 1998-2008 Ralf S. Engelschall <rse@engelschall.com>
    ##

    DIFS="$IFS"

    #   parse out -L and -l options from command line
    DIRS=''
    LIBS=''
    ARGV=''
    optprev=''
    for opt
    do
        #   concatenate with previous option if exists
        if [ ".$optprev" != . ]; then
            opt="${optprev}${opt}";
            optprev=''
        fi
        #   remember options for arg if used stand-alone
        if [ ".$opt" = ".-L" ] || [ ".$opt" = ".-l" ]; then
            optprev="$opt"
            continue;
        fi
        #   split argument into option plus option argument
        arg="`echo $opt | cut -c3-`"
        opt="`echo $opt | cut -c1-2`"
        #   store into containers
        case $opt in
            -L) DIRS="$DIRS:$arg" ;;
            -l) LIBS="$LIBS:$arg" ;;
             *) ARGV="$ARGV $opt" ;;
        esac
    done

    #   set linker default directories
    DIRS_DEFAULT='/lib:/usr/lib'
    if [ ".$LD_LIBRARY_PATH" != . ]; then
        DIRS_DEFAULT="$DIRS_DEFAULT:$LD_LIBRARY_PATH"
    fi

    #   sort options by class
    DIRS_OBJ=''
    LIBS_OBJ=''
    DIRS_PIC=''
    LIBS_PIC=''
    DIRS_DSO=''
    LIBS_DSO=''

    #    for each library...
    OIFS="$IFS"; IFS=':'
    for lib in $LIBS; do
        [ ".$lib" = . ] && continue

        found='no'
        found_indefdir='no'
        found_type=''
        found_dir=''

        #    for each directory...
        OIFS2="$IFS"; IFS=":$DIFS"
        for dir in ${DIRS} switch-to-defdirs ${DIRS_DEFAULT}; do
            [ ".$dir" = . ] && continue
            [ ".$dir" = .switch-to-defdirs ] && found_indefdir=yes
            [ ! -d $dir ] && continue

            #    search the file
            OIFS3="$IFS"; IFS="$DIFS"
            for file in '' `cd $dir && env -i /bin/ls lib${lib}.* 2>/dev/null`; do
                 [ ".$file" = . ] && continue
                 case $file in
                     *.so|*.so.[0-9]*|*.sl|*.sl.[0-9]* )
                          found=yes;
                          found_type=DSO;
                          break
                          ;;
                     *.lo|*.la )
                          found=yes;
                          found_type=PIC
                          ;;
                     *.a )
                          if [ ".$found_type" = . ]; then
                              found=yes
                              found_type=OBJ
                          fi
                          ;;
                 esac
            done
            IFS="$OIFS3"
            if [ ".$found" = .yes ]; then
                found_dir="$dir"
                break
            fi
        done
        IFS="$OIFS2"

        if [ ".$found" = .yes ]; then
            if [ ".$found_indefdir" != .yes ]; then
                eval "dirlist=\"\${DIRS_${found_type}}:\""
                case "$dirlist" in
                    *:$found_dir:* ) ;;
                    * ) eval "DIRS_${found_type}=\"\$DIRS_${found_type}:${found_dir}\"" ;;
                esac
                eval "LIBS_${found_type}=\"\$LIBS_${found_type}:$lib\""
            else
                eval "LIBS_${found_type}=\"\$LIBS_${found_type}:$lib\""
            fi
        else
            LIBS_OBJ="$LIBS_OBJ:$lib"
            #dirlist="`echo $DIRS $DIRS_DEFAULT | sed -e 's/:/ /g'`"
            #echo "slo:Warning: library \"$lib\" not found in any of the following dirs:" 2>&1
            #echo "slo:Warning: $dirlist" 1>&1
        fi
    done
    IFS="$OIFS"

    #   also pass-through unused dirs even if it's useless
    OIFS="$IFS"; IFS=':'
    for dir in $DIRS; do
        dirlist="${DIRS_OBJ}:${DIRS_PIC}:${DIRS_DSO}:"
        case "$dirlist" in
            *:$dir:* ) ;;
            * ) DIRS_OBJ="$DIRS_OBJ:$dir" ;;
        esac
    done
    IFS="$OIFS"

    #   reassemble the options but separated by type
    for type in OBJ PIC DSO; do
        OIFS="$IFS"; IFS=':'
        eval "libs=\"\$LIBS_${type}\""
        opts=''
        for lib in $libs; do
            [ ".$lib" = . ] && continue
            opts="$opts -l$lib"
        done
        eval "LIBS_${type}=\"$opts\""

        eval "dirs=\"\$DIRS_${type}\""
        opts=''
        for dir in $dirs; do
            [ ".$dir" = . ] && continue
            opts="$opts -L$dir"
        done
        eval "DIRS_${type}=\"$opts\""
        IFS="$OIFS"
    done

    #   give back results
    for var in ARGV DIRS_OBJ LIBS_OBJ DIRS_PIC LIBS_PIC DIRS_DSO LIBS_DSO; do
        eval "val=\"\$${var}\""
        val="`echo $val | sed -e 's/^ *//'`"
        echo "${opt_p}${var}=\"${val}\""
    done

    shtool_exit 0
    ;;

scpp )
    ##
    ##  scpp -- Sharing C Pre-Processor
    ##  Copyright (c) 1999-2008 Ralf S. Engelschall <rse@engelschall.com>
    ##

    srcs="$*"
    output="${opt_o}.n"

    #   find a reasonable Awk
    awk=''
    paths=`echo $PATH |\
           sed -e 's%/*:%:%g' -e 's%/$%%' \
               -e 's/^:/.:/' -e 's/::/:.:/g' -e 's/:$/:./' \
               -e 's/:/ /g'`
    for name in gawk nawk awk; do
        for path in $paths; do
            if [ -r "$path/$name" ]; then
                awk="$path/$name"
                break
            fi
        done
        if [ ".$awk" != . ]; then
            break
        fi
    done
    if [ ".$awk" = . ]; then
        echo "$msgprefix:Error: cannot find a reasonable Awk" 1>&2
        shtool_exit 1
    fi

    #   parse source file(s)
    if [ ".$opt_v" = .yes ]; then
        echo "Parsing:" | $awk '{ printf("%s", $0); }' 1>&2
    fi
    for src in $srcs; do
        if [ ".$opt_v" = .yes ]; then
            echo $src | $awk '{ printf(" %s", $0); }' 1>&2
        fi
        if [ ".$opt_f" != . ]; then
            inputcmd="sed"
            OIFS="$IFS"; IFS="$ASC_NL"; set -- $opt_f; IFS="$OIFS"
            for e
            do
                inputcmd="$inputcmd -e '$e'"
            done
            inputcmd="$inputcmd '$src'"
        else
            inputcmd="cat '$src'"
        fi
        eval $inputcmd |\
        $awk '
           BEGIN {
               ln    = 0;
               fln   = 0;
               level = 0;
               mode  = "";
               store = "";
           }
           {
               ln++;
           }
           /^#if.*/ {
               level++;
           }
           /^#if [a-zA-Z_][a-zA-Z0-9_]* *$/ {
               if ($2 == define) {
                   mode = "D";
                   printf("D:#line %d \"%s\"\n", ln, src);
                   next;
               }
           }
           /^#endif.*/ {
               level--;
               if (mode == "D" && level == 0) {
                   mode = "";
                   next;
               }
           }
           /^[a-zA-Z_][a-zA-Z0-9_].*;.*/ {
               if ($1 == class) {
                   printf("V:#line %d \"%s\"\n", ln, src);
                   printf("V:%s\n", $0);
                   printf("J:%s\n", $0);
                   next;
               }
           }
           /^[a-zA-Z_][a-zA-Z0-9_].*=.*/ {
               if ($1 == class) {
                   printf("V:#line %d \"%s\"\n", ln, src);
                   printf("V:%s\n", $0);
                   printf("J:%s\n", $0);
                   next;
               }
           }
           /^[a-zA-Z_][a-zA-Z0-9_]*/ {
               if ($1 == class) {
                   fln = ln;
                   store = $0;
                   mode = "F";
                   next;
               }
           }
           /^\{ *$/ {
               if (mode == "F") {
                   printf("F:#line %d \"%s\"\n", fln, src);
                   printf("F:%s;\n", store);
                   printf("I:%s;\n", store);
                   store = "";
                   mode = "";
                   next;
               }
           }
           {
               if (mode == "D")
                   printf("D:%s\n", $0);
               else if (mode == "F")
                   store = store " " $0;
           }
        ' "src=$src" "define=$opt_D" "class=$opt_C" >>$tmpfile
    done
    if [ ".$opt_v" = .yes ]; then
        echo "" 1>&2
    fi

    #   start generating output header
    echo "/* $opt_o -- autogenerated from $opt_t, DO NOT EDIT! */" >$output
    echo "#line 1 \"$opt_t\"" >>$output
    sed <$opt_t -e "1,/^${opt_M} *\$/p" -e 'd' |\
    sed -e "/^${opt_M} *\$/d" >>$output

    #   merge in the define blocks
    grep '^D:' $tmpfile | sed -e 's/^D://' >>$output

    #   generate standard prolog
    echo "#line 1 \"_ON_THE_FLY_\"" >>$output
    echo "" >>$output
    echo "/* make sure the scpp source extensions are skipped */" >>$output
    echo "#define $opt_D 0" >>$output
    echo "#define $opt_C /**/" >>$output

    #   generate namespace hiding for variables
    echo "" >>$output
    echo "/* move intern variables to hidden namespace */" >>$output
    grep '^J:' $tmpfile | sed >>$output \
        -e 's/^J://' \
        -e 's/  */ /g' \
        -e 's/^[^=;]*[ *]\([a-zA-Z0-9_]*\)\[\];.*$/#define \1 __\1/' \
        -e 's/^[^=;]*[ *]\([a-zA-Z0-9_]*\)\[\] =.*$/#define \1 __\1/' \
        -e 's/^[^=;]*[ *]\([a-zA-Z0-9_]*\);.*$/#define \1 __\1/' \
        -e 's/^[^=;]*[ *]\([a-zA-Z0-9_]*\) =.*$/#define \1 __\1/'

    #   generate namespace hiding for functions
    echo "" >>$output
    echo "/* move intern functions to hidden namespace */" >>$output
    grep '^I:' $tmpfile | sed >>$output \
        -e 's/^I://' \
        -e 's/\([ (]\) */\1/g' \
        -e 's/ *\([),]\)/\1/g' \
        -e 's/^[^(]*[ *]\([a-zA-Z0-9_]*\)(.*$/#define \1 __\1/'

    #   generate prototypes for variables
    echo "" >>$output
    echo "/* prototypes for intern variables */" >>$output
    grep '^V:' $tmpfile | sed >>$output \
        -e 's/^V://' \
        -e 's/  */ /g' \
        -e 's/^\([^=;]*[ *][a-zA-Z0-9_]*\[\]\);.*$/\1;/' \
        -e 's/^\([^=;]*[ *][a-zA-Z0-9_]*\[\]\) =.*$/\1;/' \
        -e 's/^\([^=;]*[ *][a-zA-Z0-9_]*\);.*$/\1;/' \
        -e 's/^\([^=;]*[ *][a-zA-Z0-9_]*\) =.*$/\1;/' \
        -e 's/ ;/;/g' \
        -e "s/^$opt_C /extern /"

    #   generate prototypes for functions
    echo "" >>$output
    echo "/* prototypes for intern functions */" >>$output
    grep '^F:' $tmpfile | sed >>$output \
        -e 's/^F://' \
        -e 's/\([ (]\) */\1/g' \
        -e 's/ *\([),]\)/\1/g' \
        -e 's/\([* ]\)[a-zA-Z0-9_]*,/\1,/g' \
        -e 's/\([* ]\)[a-zA-Z0-9_]*);/\1);/g' \
        -e 's/(\*[a-zA-Z0-9_]*)(/(*)(/g' \
        -e 's/\([ (]\) */\1/g' \
        -e 's/ *\([),]\)/\1/g' \
        -e "s/^$opt_C /extern /"

    #   finish generating output header
    n=`(echo ''; sed <$opt_t -e "1,/^${opt_M} *\$/p" -e 'd') |\
       wc -l | sed -e 's;^ *\([0-9]*\) *$;\1;'`
    echo "#line $n \"$opt_t\"" >>$output
    sed <$opt_t -e "/^${opt_M} *\$/,\$p" -e 'd' |\
    sed -e "/^${opt_M} *\$/d" >>$output

    #   create final output file
    if [ -f $opt_o ]; then
        if [ ".$opt_p" = .yes ]; then
            grep -v '^#line' $opt_o  >$tmpfile.o
            grep -v '^#line' $output >$tmpfile.n
            out_old="$tmpfile.o"
            out_new="$tmpfile.n"
        else
            out_old="$opt_o"
            out_new="$output"
        fi
        if cmp -s $out_old $out_new; then
            :
        else
            cp $output $opt_o
        fi
    else
        cp $output $opt_o
    fi
    rm -f $output
    rm -f $tmpfile $tmpfile.* >/dev/null 2>&1

    shtool_exit 0
    ;;

version )
    ##
    ##  version -- Maintain a version information file
    ##  Copyright (c) 1994-2008 Ralf S. Engelschall <rse@engelschall.com>
    ##

    file="$1"

    #   determine prefix and name
    name="$opt_n"
    prefix="$opt_p"

    #   determine current version
    triple="$opt_s"
    if [ ".$triple" != . ]; then
        #   use given triple
        if [ ".`echo $triple | grep '[0-9]*.[0-9]*[sabp.][0-9]*'`" = . ]; then
            echo "$msgprefix:Error: invalid argument to option \`-s': \`$opt_s'" 1>&2
            shtool_exit 1
        fi
        eval `echo $triple |\
              sed -e 's%\([0-9]*\)\.\([0-9]*\)\([sabp.]\)\([0-9]*\).*%\
              ver="\1";rev="\2";typ="\3";lev="\4"%'`
        tim=calc
    elif [ -r $file ]; then
        #   determine triple from given file
        eval `grep 'Version [0-9]*.[0-9]*[sabp.][0-9]* ([0-9]*-[a-zA-Z]*-[0-9]*)' $file |\
              sed -e 's%.*Version \([0-9]*\)\.\([0-9]*\)\([sabp.]\)\([0-9]*\) (\([0-9]*-[a-zA-Z]*-[0-9]*\)).*%\
              ver="\1";rev="\2";typ="\3";lev="\4";tim="\5"%' -e 'q'`
    else
        #   intialise to first version
        ver=0
        rev=1
        typ=.
        lev=0
        tim=calc
    fi

    #   determine new version in batch
    if [ ".$opt_i" != . ]; then
        case $opt_i in
            v ) ver=`expr $ver + 1`
                rev=0
                lev=0
                ;;
            r ) rev=`expr $rev + 1`
                lev=0
                ;;
            l ) lev=`expr $lev + 1`
                ;;
            * ) echo "$msgprefix:Error: invalid argument to option \`-i': \`$opt_i'" 1>&2
                shtool_exit 1
                ;;
        esac
        tim=calc
    fi

    #   determine new version interactively
    if [ ".$opt_e" = .yes ]; then
        echo "old version: ${ver}.${rev}${typ}${lev}"
        while [ 1 ]; do
            echo dummy | awk '{ printf("new version: "); }'
            read triple
            case $triple in
                [0-9]*.[0-9]*[sabp.][0-9]* )
                    ;;
                * ) echo "$msgprefix:Error: invalid version string entered: \`$triple'" 1>&2
                    continue
                    ;;
            esac
            break
        done
        eval `echo $triple |\
              sed -e 's%^\([0-9]*\)\.\([0-9]*\)\([sabp.]\)\([0-9]*\)$%\
              ver="\1";rev="\2";typ="\3";lev="\4"%'`
        tim=calc
    fi

    #   determine hexadecimal and libtool value of version
    case $typ in
        a     ) typnum=0;  levnum=$lev ;;
        b     ) typnum=1;  levnum=$lev ;;
        p | . ) typnum=2;  levnum=$lev ;;
        s     ) typnum=15; levnum=255  ;; # snapshots are special
    esac
    hex=`echo "$ver:$rev:$typnum:$levnum" |\
         awk -F: '{ printf("0x%x%02x%1x%02x", $1, $2, $3, $4); }' |\
         tr 'abcdef' 'ABCDEF'`
    ltv=`echo "$ver:$rev:$typnum:$levnum" |\
         awk -F: '{ printf("%d:%d", $1*10 + $2, $3*10 + $4); }'`

    #   determine date
    if [ ".$tim" = .calc ]; then
        day=`date '+%d'`
        month=`date '+%m'`
        year=`date '+%Y' 2>/dev/null`
        if [ ".$time_year" = . ]; then
            year=`date '+%y'`
            case $year in
                [5-9][0-9]) year="19$year" ;;
                [0-4][0-9]) year="20$year" ;;
            esac
        fi
        case $month in
            1|01) month='Jan' ;;
            2|02) month='Feb' ;;
            3|03) month='Mar' ;;
            4|04) month='Apr' ;;
            5|05) month='May' ;;
            6|06) month='Jun' ;;
            7|07) month='Jul' ;;
            8|08) month='Aug' ;;
            9|09) month='Sep' ;;
              10) month='Oct' ;;
              11) month='Nov' ;;
              12) month='Dec' ;;
        esac
        tim="${day}-${month}-${year}"
    fi

    #   perform result actions
    mode=show
    if [ ".$opt_i" != . ]; then
        mode=edit
    elif [ ".$opt_e" = .yes ]; then
        mode=edit
    elif [ ".$opt_s" != . ]; then
        mode=edit
    fi
    if [ ".$mode" = .show ]; then
        #   just display the current version
        case $opt_d in
            short )
                echo "${ver}.${rev}${typ}${lev}"
                ;;
            long )
                echo "${ver}.${rev}${typ}${lev} ($tim)"
                ;;
            libtool )
                echo "${ltv}"
                ;;
            hex )
                echo "${hex}"
                ;;
            * ) echo "$msgprefix:Error: invalid argument to option \`-d': \`$opt_d'" 1>&2
                shtool_exit 1
                ;;
        esac
    else
        #   update the version file

        #   pre-generate various strings
        triple="${ver}.${rev}${typ}${lev}"
        vHex="$hex"
        vShort="${triple}"
        vLong="${triple} (${tim})"
        vTeX="This is ${name}, Version ${triple} (${tim})"
        vGNU="${name} ${triple} (${tim})"
        vWeb="${name}/${triple}"
        vSCCS="@(#)${name} ${triple} (${tim})"
        vRCS="\$Id: ${name} ${triple} (${tim}) \$"

        #   determine string out of filename
        #   (do NOT try to optimize this in any way because of portability)
        filestr=`util_upper "$file" | tr './%+' '____' | sed -e 's/-/_/g'`

        #   generate uppercase prefix
        prefixupper=`util_upper "$prefix"`

        #   create the version file according the the selected language
        echo "new version: ${vLong}"

        cp /dev/null $file
        case $opt_l in
            txt )
                echo >>$file ""
                echo >>$file "  ${file} -- Version Information for ${name} (syntax: Text)"
                echo >>$file "  [automatically generated and maintained by GNU shtool]"
                echo >>$file ""
                echo >>$file "  $vTeX"
                echo >>$file ""
                ;;
            c )
                echo >>$file "/*"
                echo >>$file "**  ${file} -- Version Information for ${name} (syntax: C/C++)"
                echo >>$file "**  [automatically generated and maintained by GNU shtool]"
                echo >>$file "*/"
                echo >>$file ""
                echo >>$file "#ifdef _${filestr}_AS_HEADER_"
                echo >>$file ""
                echo >>$file "#ifndef _${filestr}_"
                echo >>$file "#define _${filestr}_"
                echo >>$file ""
                echo >>$file "#define ${prefixupper}VERSION ${vHex}"
                echo >>$file ""
                echo >>$file "typedef struct {"
                echo >>$file "    const int   v_hex;"
                echo >>$file "    const char *v_short;"
                echo >>$file "    const char *v_long;"
                echo >>$file "    const char *v_tex;"
                echo >>$file "    const char *v_gnu;"
                echo >>$file "    const char *v_web;"
                echo >>$file "    const char *v_sccs;"
                echo >>$file "    const char *v_rcs;"
                echo >>$file "} ${prefix}version_t;"
                echo >>$file ""
                echo >>$file "extern ${prefix}version_t ${prefix}version;"
                echo >>$file ""
                echo >>$file "#endif /* _${filestr}_ */"
                echo >>$file ""
                echo >>$file "#else /* _${filestr}_AS_HEADER_ */"
                echo >>$file ""
                echo >>$file "#define _${filestr}_AS_HEADER_"
                echo >>$file "#include \"${file}\""
                echo >>$file "#undef  _${filestr}_AS_HEADER_"
                echo >>$file ""
                echo >>$file "${prefix}version_t ${prefix}version = {"
                echo >>$file "    ${vHex},"
                echo >>$file "    \"${vShort}\","
                echo >>$file "    \"${vLong}\","
                echo >>$file "    \"${vTeX}\","
                echo >>$file "    \"${vGNU}\","
                echo >>$file "    \"${vWeb}\","
                echo >>$file "    \"${vSCCS}\","
                echo >>$file "    \"${vRCS}\""
                echo >>$file "};"
                echo >>$file ""
                echo >>$file "#endif /* _${filestr}_AS_HEADER_ */"
                echo >>$file ""
                ;;
            m4 )
                echo >>$file "##"
                echo >>$file "##  ${file} -- Version Information for ${name} (syntax: M4)"
                echo >>$file "##  [automatically generated and maintained by GNU shtool]"
                echo >>$file "##"
                echo >>$file ""
                echo >>$file "m4_define([v_hex],   [${vHex}])"
                echo >>$file "m4_define([v_short], [${vShort}])"
                echo >>$file "m4_define([v_long],  [${vLong}])"
                echo >>$file "m4_define([v_tex],   [${vTeX}])"
                echo >>$file "m4_define([v_gnu],   [${vGNU}])"
                echo >>$file "m4_define([v_web],   [${vWeb}])"
                echo >>$file "m4_define([v_sccs],  [${vSCCS}])"
                echo >>$file "m4_define([v_rcs],   [${vRCS}])"
                echo >>$file ""
                ;;
            perl )
                echo >>$file "##"
                echo >>$file "##  ${file} -- Version Information for ${name} (syntax: Perl)"
                echo >>$file "##  [automatically generated and maintained by GNU shtool]"
                echo >>$file "##"
                echo >>$file ""
                echo >>$file "our \$${prefix}version = {"
                echo >>$file "    'v_hex'   => ${vHex},"
                echo >>$file "    'v_short' => \"${vShort}\","
                echo >>$file "    'v_long'  => \"${vLong}\","
                echo >>$file "    'v_tex'   => \"${vTeX}\","
                echo >>$file "    'v_gnu'   => \"${vGNU}\","
                echo >>$file "    'v_web'   => \"${vWeb}\","
                echo >>$file "    'v_sccs'  => \"${vSCCS}\","
                echo >>$file "    'v_rcs'   => \"\\${vRCS}/\""
                echo >>$file "};"
                echo >>$file ""
                echo >>$file "1;"
                echo >>$file ""
                ;;
            python )
                echo >>$file "##"
                echo >>$file "##  ${file} -- Version Information for ${name} (syntax: Python)"
                echo >>$file "##  [automatically generated and maintained by GNU shtool]"
                echo >>$file "##"
                echo >>$file ""
                echo >>$file "class ${prefix}version:"
                echo >>$file "    v_hex       = ${vHex}"
                echo >>$file "    v_short     = \"${vShort}\""
                echo >>$file "    v_long      = \"${vLong}\""
                echo >>$file "    v_tex       = \"${vTeX}\""
                echo >>$file "    v_gnu       = \"${vGNU}\""
                echo >>$file "    v_web       = \"${vWeb}\""
                echo >>$file "    v_sccs      = \"${vSCCS}\""
                echo >>$file "    v_rcs       = \"${vRCS}\""
                echo >>$file ""
                ;;
            * ) echo "$msgprefix:Error: invalid argument to option \`-l': \`$opt_l'" 1>&2
                shtool_exit 1
                ;;
        esac
    fi

    shtool_exit 0
    ;;

path )
    ##
    ##  path -- Deal with program paths
    ##  Copyright (c) 1998-2008 Ralf S. Engelschall <rse@engelschall.com>
    ##

    namelist="$*"

    #   check whether the test command supports the -x option
    if [ -x /bin/sh ] 2>/dev/null; then
        minusx="-x"
    else
        minusx="-r"
    fi

    #   split path string
    paths="`echo $opt_p |\
            sed -e 's/^:/.:/' \
                -e 's/::/:.:/g' \
                -e 's/:$/:./' \
                -e 's/:/ /g'`"

    #   SPECIAL REQUEST
    #   translate forward to reverse path
    if [ ".$opt_r" = .yes ]; then
        if [ "x$namelist" = "x." ]; then
            rp='.'
        else
            rp=''
            for pe in `IFS="$IFS/"; echo $namelist`; do
                rp="../$rp"
            done
        fi
        echo $rp | sed -e 's:/$::'
        shtool_exit 0
    fi

    #   SPECIAL REQUEST
    #   strip out directory or base name
    if [ ".$opt_d" = .yes ]; then
        echo "$namelist" |\
        sed -e 's;[^/]*$;;' -e 's;\(.\)/$;\1;'
        shtool_exit 0
    fi
    if [ ".$opt_b" = .yes ]; then
        echo "$namelist" |\
        sed -e 's;.*/\([^/]*\)$;\1;'
        shtool_exit 0
    fi

    #   MAGIC SITUATION
    #   Perl Interpreter (perl)
    if [ ".$opt_m" = .yes ] && [ ".$namelist" = .perl ]; then
        rm -f $tmpfile >/dev/null 2>&1
        touch $tmpfile
        found=0
        pc=99
        for dir in $paths; do
            dir=`echo $dir | sed -e 's;/*$;;'`
            nc=99
            for name in perl perl5 miniperl; do
                 if [ $minusx "$dir/$name" ] && [ ! -d "$dir/$name" ]; then
                     perl="$dir/$name"
                     pv=`$perl -e 'printf("%.3f", $]);'`
                     echo "$pv:$pc:$nc:$perl" >>$tmpfile
                     found=1
                 fi
                 nc=`expr $nc - 1`
            done
            pc=`expr $pc - 1`
        done
        if [ $found = 1 ]; then
            perl="`cat $tmpfile | sort -r -u | sed -e 'q' | cut -d: -f4`"
            rm -f $tmpfile >/dev/null 2>&1
            echo "$perl"
            shtool_exit 0
        fi
        rm -f $tmpfile >/dev/null 2>&1
        shtool_exit 1
    fi

    #   MAGIC SITUATION
    #   C pre-processor (cpp)
    if [ ".$opt_m" = .yes ] && [ ".$namelist" = .cpp ]; then
        echo >$tmpfile.c "#include <assert.h>"
        echo >>$tmpfile.c "Syntax Error"
        #   1. try the standard cc -E approach
        cpp="${CC-cc} -E"
        (eval "$cpp $tmpfile.c >/dev/null") 2>$tmpfile.out
        my_error=`grep -v '^ *+' $tmpfile.out`
        if [ ".$my_error" != . ]; then
            #   2. try the cc -E approach and GCC's -traditional-ccp option
            cpp="${CC-cc} -E -traditional-cpp"
            (eval "$cpp $tmpfile.c >/dev/null") 2>$tmpfile.out
            my_error=`grep -v '^ *+' $tmpfile.out`
            if [ ".$my_error" != . ]; then
                #   3. try a standalone cpp command in path and lib dirs
                for path in $paths /lib /usr/lib /usr/local/lib; do
                    path=`echo $path | sed -e 's;/*$;;'`
                    if [ $minusx "$path/cpp" ] && [ ! -d "$path/cpp" ]; then
                        cpp="$path/cpp"
                        break
                    fi
                done
                if [ ".$cpp" != . ]; then
                    (eval "$cpp $tmpfile.c >/dev/null") 2>$tmpfile.out
                    my_error=`grep -v '^ *+' $tmpfile.out`
                    if [ ".$my_error" != . ]; then
                        #   ok, we gave up...
                        cpp=''
                    fi
                fi
            fi
        fi
        rm -f $tmpfile >/dev/null 2>&1
        rm -f $tmpfile.c $tmpfile.out >/dev/null 2>&1
        if [ ".$cpp" != . ]; then
            echo "$cpp"
            shtool_exit 0
        fi
        shtool_exit 1
    fi

    #   STANDARD SITUATION
    #   iterate over names
    for name in $namelist; do
        #   iterate over paths
        for path in $paths; do
            path=`echo $path | sed -e 's;/*$;;'`
            if [ $minusx "$path/$name" ] && [ ! -d "$path/$name" ]; then
                if [ ".$opt_s" != .yes ]; then
                    echo "$path/$name"
                fi
                shtool_exit 0
            fi
        done
    done

    shtool_exit 1
    ;;

esac

shtool_exit 0

